{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Acerca de \u00b6 Esta p\u00e1gina es el cuaderno de actividades de Francisco Campuzano Jim\u00e9nez de la asignatura de Ingenier\u00eda de Prote\u00ednas del curso 2021-2022 sobre la prote\u00edna Human glutaminyl cyclase (hQC). Representaci\u00f3n de la estructura 2AFM obtenida usando 3D Protein Imaging Contenido del cuaderno de actividades \u00b6 Este cuaderno est\u00e1 formado por las actividades 1\u00aa-9\u00aa y un ejercicio extra propuesto por el alumno. No se incluye, por tanto, en esta relaci\u00f3n de ejercicios la actividad 10\u00aa, al haber decidido sustituirla por las actividades 4\u00aa y 9\u00aa. Se ha optado por esta opci\u00f3n porque a lo largo de la asignatura se llevaron a cabo los ejercicios de forma ordenada y estos ya hab\u00edan sido realizados antes de la modificaci\u00f3n de la relaci\u00f3n de actividades. Adem\u00e1s, se incluye una actividad adicional, el an\u00e1lisis de trayectoria de una simulaci\u00f3n de Din\u00e1mica Molecular realizada. Esta actividad fue motivada por el profesor, que nos anim\u00f3 a explorar la prote\u00edna asignada de forma independiente y a incluir los resultados en el presente trabajo. Repositorio \u00b6 Este cuaderno est\u00e1 formado, por un lado, por un repositorio albergado en github , con el cual se puede acceder al c\u00f3digo empleado en la realizaci\u00f3n de este trabajo. Adem\u00e1s, gracias al uso de Git, un software de control de versiones, se puede acceder al historial de versiones del proyecto, pudiendo observar c\u00f3mo este cuaderno realizado de forma progresiva e incluso estudiar el c\u00f3digo en cada uno de los momentos. Al hacer p\u00fablico y accesible este material se est\u00e1 facilitando el seguimiento de la asignatura a futuros compa\u00f1eros y compa\u00f1eras. P\u00e1gina web \u00b6 Por otro lado, este cuaderno est\u00e1 formado por esta p\u00e1gina web albergada en Github. Se ha optado por este formado porque facilitaba la tarea de incluir animaciones, bloques de c\u00f3digo y hacer p\u00fablico el resultado. Para realizarla se ha usado el software MkDocs , el cual permite generar sitios web est\u00e1ticos (y que por tanto pueden alojarse de forma gratuita en un repositorio) a partir de Markdown. Este software est\u00e1 espec\u00edficamente dise\u00f1ado para crear la documentaci\u00f3n de un proyecto y era, por tanto, ideal para este caso. Adem\u00e1s, se ha utilizado dentro de un GitHub workflow. Este workflow consiste en una serie de comandos que se ejecutan en la nube y que se encargan de instalar los programas necesarios y luego \"transcribir\" los archivos markdown en archivos html. Este sitio web se ha realizado empleando la plantilla creada por el Aula de Software Libre de la Universidad de C\u00f3rdoba . Licencia \u00b6 El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Acerca de"},{"location":"#acerca-de","text":"Esta p\u00e1gina es el cuaderno de actividades de Francisco Campuzano Jim\u00e9nez de la asignatura de Ingenier\u00eda de Prote\u00ednas del curso 2021-2022 sobre la prote\u00edna Human glutaminyl cyclase (hQC). Representaci\u00f3n de la estructura 2AFM obtenida usando 3D Protein Imaging","title":"Acerca de"},{"location":"#contenido-del-cuaderno-de-actividades","text":"Este cuaderno est\u00e1 formado por las actividades 1\u00aa-9\u00aa y un ejercicio extra propuesto por el alumno. No se incluye, por tanto, en esta relaci\u00f3n de ejercicios la actividad 10\u00aa, al haber decidido sustituirla por las actividades 4\u00aa y 9\u00aa. Se ha optado por esta opci\u00f3n porque a lo largo de la asignatura se llevaron a cabo los ejercicios de forma ordenada y estos ya hab\u00edan sido realizados antes de la modificaci\u00f3n de la relaci\u00f3n de actividades. Adem\u00e1s, se incluye una actividad adicional, el an\u00e1lisis de trayectoria de una simulaci\u00f3n de Din\u00e1mica Molecular realizada. Esta actividad fue motivada por el profesor, que nos anim\u00f3 a explorar la prote\u00edna asignada de forma independiente y a incluir los resultados en el presente trabajo.","title":"Contenido del cuaderno de actividades"},{"location":"#repositorio","text":"Este cuaderno est\u00e1 formado, por un lado, por un repositorio albergado en github , con el cual se puede acceder al c\u00f3digo empleado en la realizaci\u00f3n de este trabajo. Adem\u00e1s, gracias al uso de Git, un software de control de versiones, se puede acceder al historial de versiones del proyecto, pudiendo observar c\u00f3mo este cuaderno realizado de forma progresiva e incluso estudiar el c\u00f3digo en cada uno de los momentos. Al hacer p\u00fablico y accesible este material se est\u00e1 facilitando el seguimiento de la asignatura a futuros compa\u00f1eros y compa\u00f1eras.","title":"Repositorio"},{"location":"#pagina-web","text":"Por otro lado, este cuaderno est\u00e1 formado por esta p\u00e1gina web albergada en Github. Se ha optado por este formado porque facilitaba la tarea de incluir animaciones, bloques de c\u00f3digo y hacer p\u00fablico el resultado. Para realizarla se ha usado el software MkDocs , el cual permite generar sitios web est\u00e1ticos (y que por tanto pueden alojarse de forma gratuita en un repositorio) a partir de Markdown. Este software est\u00e1 espec\u00edficamente dise\u00f1ado para crear la documentaci\u00f3n de un proyecto y era, por tanto, ideal para este caso. Adem\u00e1s, se ha utilizado dentro de un GitHub workflow. Este workflow consiste en una serie de comandos que se ejecutan en la nube y que se encargan de instalar los programas necesarios y luego \"transcribir\" los archivos markdown en archivos html. Este sitio web se ha realizado empleando la plantilla creada por el Aula de Software Libre de la Universidad de C\u00f3rdoba .","title":"P\u00e1gina web"},{"location":"#licencia","text":"El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Licencia"},{"location":"alinearZ/","text":"Alinear Z \u00b6 En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una aplicaci\u00f3n capaz de proyectar en el plano las posiciones de los Ca de un fragmento definido de la prote\u00edna y realizar las transformaciones necesarias para superponer el primer y \u00faltimo punto en dicha proyecci\u00f3n. El c\u00f3digo correspondiente a las funciones utilizadas para la transformaci\u00f3n (traslaci\u00f3n y giro) las coordenadas se encuentran en la librer\u00eda biotools/src_biotools y la aplicaci\u00f3n bajo el nombre de alinear_Z . Este apartado se corresponde a la 8\u00aa actividad de la relaci\u00f3n de ejercicios. Transformaciones para superponer dos puntos \u00b6 A continuaci\u00f3n, vamos a detallar las transformaciones que deben de realizarse sobre los el conjunto de puntos correspondientes a los \\(\\text{C}_\\alpha\\) , las cuales fueron tratadas en clase. Destacar que, aunque en clase se vio de forma te\u00f3rica c\u00f3mo se podr\u00eda resolver el problema de forma matricial (usando matrices de transformaci\u00f3n para hacer computacionalmente menos costoso el problema), la implementaci\u00f3n consiste en la aplicaci\u00f3n sucesiva de las funciones de transformaci\u00f3n ya desarrolladas. Consideraremos que dicho conjunto de coordenadas at\u00f3micas correspondiente a los \\(\\text{C}_\\alpha\\) es el siguiente: \\[ C = \\{\\vec{p_1}, \\vec{p_2}, ..., \\vec{p_{n-i}}, \\vec{p_n}\\} \\] y donde cada elemento es un vector tal que \\[ \\vec{p_1}= \\begin{pmatrix}x_i & y_i & z_i\\end{pmatrix} \\] Destacar que, en el desarrollo te\u00f3rico matricial estudiado en clase, deber\u00edamos considerar en las matrices una \"columna extra\" de 1. Las transformaciones que realizaremos son las siguientes: 1.Traslaci\u00f3n del conjunto de puntos en el espacio de modo que se cumpla que \\(T(\\vec{p_1})= \\begin{pmatrix}0 & 0 & 0\\end{pmatrix}\\) . 2.Rotaci\u00f3n del conjunto de puntos respecto al eje \\(x\\) de modo que el punto n-\u00e9simo que ha sido previamente transladado, \\(\\vec{p_n}'\\) , cumpla que \\[ Rot_{OX}(\\vec{p_n}')= \\begin{pmatrix}x'_n & 0 & z'_n\\end{pmatrix} \\] 3.Rotaci\u00f3n del conjunto de puntos respecto al eje \\(y\\) hasta que la trayectoria del vector \\(\\vec{v} = \\vec{p_n}'-\\vec{p_1}'\\) coincida con el eje \\(z\\) . O, dicho de otro modo, hasta que se cumpla que: \\[ Rot_{OY}(\\vec{p_n}'')= \\begin{pmatrix}0 & 0 & z''_n\\end{pmatrix} \\] Criterio de signos \u00b6 El criterio de signos empleado es el siguiente. Dados unos valores del punto n-esimo, para alinear correctamente el primer punto con este, se considera si \\(z_n>0\\) . Si la coordenada \\(z\\) del punto n-\u00e9simo es mayor que 0, es decir, que est\u00e1 en uno de los 4 cuadrantes superiores (considerando que el eje \\(z\\) se encuentra en vertical en nuestro sistema de referencia), se deber\u00e1 rotar sobre el eje \\(\\text{OX}\\) en sentido positivo o antihorario y sobre el eje \\(\\text{OY}\\) en sentido negativo u horario, mientras que si la coordenada \\(z\\) del punto n-\u00e9simo es mayor que 0, es decir, que est\u00e1 en uno de los 4 cuadrantes inferiores, se deber\u00e1 rotar sobre el eje \\(\\text{OX}\\) en sentido negativo u horario y sobre el eje \\(\\text{OY}\\) en sentido positivo o antihorario. Finalmente, la implementaci\u00f3n de las tres transformaciones anteriores en forma de funci\u00f3n se muestra a continuaci\u00f3n: alinear_Z() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function AlinearZ ( puntos : Tpuntos ) : TPuntos ; var S : TPuntos ; p1 , p2 : TPunto ; a , b , c , d1 , d2 : real ; alpha , phi , senoAlpha , senoPhi : real ; begin setLength ( S , high ( puntos ) + 1 ) ; //Transladar p1 := puntos [ 0 ] ; S := translacion ( - p1 . X , - p1 . Y , - p1 . Z , puntos ) ; //Calcular \u00e1ngulos a := S [ high ( S )] . X ; b := S [ high ( S )] . Y ; c := S [ high ( S )] . Z ; d1 := sqrt ( sqr ( b ) + sqr ( c )) ; d2 := sqrt ( sqr ( a ) + sqr ( b ) + sqr ( c )) ; senoPhi := b / d1 ; senoAlpha := a / d2 ; phi := arcsin ( senoPhi ) ; alpha := arcsin ( senoAlpha ) ; if c < 0 then phi := - phi else alpha := - alpha ; //Cambio signo //Giro sobre OX y OY S := GiroOX ( phi , S ) ; S := GiroOY ( alpha , S ) ; result := S ; end ; Aplicaci\u00f3n Free Pascal/Lazarus \u00b6 Nuestra aplicaci\u00f3n deber\u00e1 tener, entonces, una interfaz que permita al usuario seleccionar un fragmento de la prote\u00edna, deber\u00e1 ser capaz de extraer solo los \\(\\text{C}_{\\alpha}\\) de la instancia de TPDB y dos paneles donde se muestre gr\u00e1ficamente el resultado de la transformaci\u00f3n. Adem\u00e1s, el \u00faltimo residuo del fragmento es coloreado de un color distinto, para poder comprobar con facilidad que el programa est\u00e1 funcionando adecuadamente, y se implement\u00f3 tanto un mensaje de advertencia cuando el usuario introduc\u00eda un valor de \\(\\text{C}_{\\alpha, \\text{inicial}}\\) inferior a \\(\\text{C}_{\\alpha, \\text{final}}\\) como un bot\u00f3n debajo de cada imagen para poder guardarla directamente usando un TSavePictureDialog . Por \u00faltimo, al igual que en el programa estereodiagrama , se tiene en cuenta la subunidad marcada por el usuario para restringir los residuos que el usuario puede elegir. Demostraci\u00f3n de uso \u00b6 Figura 1. Animaci\u00f3n del programa alinear_Z mostrando su uso. Verificaci\u00f3n con PyMol \u00b6 Por \u00faltimo, se pide que se compruebe la correcci\u00f3n de la transformaci\u00f3n realizada empleando un programa de visualizaci\u00f3n de prote\u00ednas. Mostramos a continuaci\u00f3n la imagen resultante de alinear los residuos 35 a 43 de la prote\u00edna 2AFM con nuestro programa: Figura 2. Proyecci\u00f3n sobre el plano de los residuos 35 a 43 de la prote\u00edna 2AFM, mostrando las coordenadas \\(y\\) frente a \\(x\\) antes y despu\u00e9s de alinear. Figura 4. Visualizaci\u00f3n de los residuos 35 a 43 de la prote\u00edna 2AFM con PyMol despu\u00e9s de alinear manualmente el primer y \u00faltimo residuo del fragmento. Como se puede observar, el programa desarrollado funciona adecuadamente y es capaz, no solo de realizar las transformaciones pertinentes, sino, tambi\u00e9n, mostrarlas gr\u00e1ficamente, aunque sea de una forma rudimentaria.","title":"Alinear Z"},{"location":"alinearZ/#alinear-z","text":"En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una aplicaci\u00f3n capaz de proyectar en el plano las posiciones de los Ca de un fragmento definido de la prote\u00edna y realizar las transformaciones necesarias para superponer el primer y \u00faltimo punto en dicha proyecci\u00f3n. El c\u00f3digo correspondiente a las funciones utilizadas para la transformaci\u00f3n (traslaci\u00f3n y giro) las coordenadas se encuentran en la librer\u00eda biotools/src_biotools y la aplicaci\u00f3n bajo el nombre de alinear_Z . Este apartado se corresponde a la 8\u00aa actividad de la relaci\u00f3n de ejercicios.","title":"Alinear Z"},{"location":"alinearZ/#transformaciones-para-superponer-dos-puntos","text":"A continuaci\u00f3n, vamos a detallar las transformaciones que deben de realizarse sobre los el conjunto de puntos correspondientes a los \\(\\text{C}_\\alpha\\) , las cuales fueron tratadas en clase. Destacar que, aunque en clase se vio de forma te\u00f3rica c\u00f3mo se podr\u00eda resolver el problema de forma matricial (usando matrices de transformaci\u00f3n para hacer computacionalmente menos costoso el problema), la implementaci\u00f3n consiste en la aplicaci\u00f3n sucesiva de las funciones de transformaci\u00f3n ya desarrolladas. Consideraremos que dicho conjunto de coordenadas at\u00f3micas correspondiente a los \\(\\text{C}_\\alpha\\) es el siguiente: \\[ C = \\{\\vec{p_1}, \\vec{p_2}, ..., \\vec{p_{n-i}}, \\vec{p_n}\\} \\] y donde cada elemento es un vector tal que \\[ \\vec{p_1}= \\begin{pmatrix}x_i & y_i & z_i\\end{pmatrix} \\] Destacar que, en el desarrollo te\u00f3rico matricial estudiado en clase, deber\u00edamos considerar en las matrices una \"columna extra\" de 1. Las transformaciones que realizaremos son las siguientes: 1.Traslaci\u00f3n del conjunto de puntos en el espacio de modo que se cumpla que \\(T(\\vec{p_1})= \\begin{pmatrix}0 & 0 & 0\\end{pmatrix}\\) . 2.Rotaci\u00f3n del conjunto de puntos respecto al eje \\(x\\) de modo que el punto n-\u00e9simo que ha sido previamente transladado, \\(\\vec{p_n}'\\) , cumpla que \\[ Rot_{OX}(\\vec{p_n}')= \\begin{pmatrix}x'_n & 0 & z'_n\\end{pmatrix} \\] 3.Rotaci\u00f3n del conjunto de puntos respecto al eje \\(y\\) hasta que la trayectoria del vector \\(\\vec{v} = \\vec{p_n}'-\\vec{p_1}'\\) coincida con el eje \\(z\\) . O, dicho de otro modo, hasta que se cumpla que: \\[ Rot_{OY}(\\vec{p_n}'')= \\begin{pmatrix}0 & 0 & z''_n\\end{pmatrix} \\]","title":"Transformaciones para superponer dos puntos"},{"location":"alinearZ/#criterio-de-signos","text":"El criterio de signos empleado es el siguiente. Dados unos valores del punto n-esimo, para alinear correctamente el primer punto con este, se considera si \\(z_n>0\\) . Si la coordenada \\(z\\) del punto n-\u00e9simo es mayor que 0, es decir, que est\u00e1 en uno de los 4 cuadrantes superiores (considerando que el eje \\(z\\) se encuentra en vertical en nuestro sistema de referencia), se deber\u00e1 rotar sobre el eje \\(\\text{OX}\\) en sentido positivo o antihorario y sobre el eje \\(\\text{OY}\\) en sentido negativo u horario, mientras que si la coordenada \\(z\\) del punto n-\u00e9simo es mayor que 0, es decir, que est\u00e1 en uno de los 4 cuadrantes inferiores, se deber\u00e1 rotar sobre el eje \\(\\text{OX}\\) en sentido negativo u horario y sobre el eje \\(\\text{OY}\\) en sentido positivo o antihorario. Finalmente, la implementaci\u00f3n de las tres transformaciones anteriores en forma de funci\u00f3n se muestra a continuaci\u00f3n: alinear_Z() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function AlinearZ ( puntos : Tpuntos ) : TPuntos ; var S : TPuntos ; p1 , p2 : TPunto ; a , b , c , d1 , d2 : real ; alpha , phi , senoAlpha , senoPhi : real ; begin setLength ( S , high ( puntos ) + 1 ) ; //Transladar p1 := puntos [ 0 ] ; S := translacion ( - p1 . X , - p1 . Y , - p1 . Z , puntos ) ; //Calcular \u00e1ngulos a := S [ high ( S )] . X ; b := S [ high ( S )] . Y ; c := S [ high ( S )] . Z ; d1 := sqrt ( sqr ( b ) + sqr ( c )) ; d2 := sqrt ( sqr ( a ) + sqr ( b ) + sqr ( c )) ; senoPhi := b / d1 ; senoAlpha := a / d2 ; phi := arcsin ( senoPhi ) ; alpha := arcsin ( senoAlpha ) ; if c < 0 then phi := - phi else alpha := - alpha ; //Cambio signo //Giro sobre OX y OY S := GiroOX ( phi , S ) ; S := GiroOY ( alpha , S ) ; result := S ; end ;","title":"Criterio de signos"},{"location":"alinearZ/#aplicacion-free-pascallazarus","text":"Nuestra aplicaci\u00f3n deber\u00e1 tener, entonces, una interfaz que permita al usuario seleccionar un fragmento de la prote\u00edna, deber\u00e1 ser capaz de extraer solo los \\(\\text{C}_{\\alpha}\\) de la instancia de TPDB y dos paneles donde se muestre gr\u00e1ficamente el resultado de la transformaci\u00f3n. Adem\u00e1s, el \u00faltimo residuo del fragmento es coloreado de un color distinto, para poder comprobar con facilidad que el programa est\u00e1 funcionando adecuadamente, y se implement\u00f3 tanto un mensaje de advertencia cuando el usuario introduc\u00eda un valor de \\(\\text{C}_{\\alpha, \\text{inicial}}\\) inferior a \\(\\text{C}_{\\alpha, \\text{final}}\\) como un bot\u00f3n debajo de cada imagen para poder guardarla directamente usando un TSavePictureDialog . Por \u00faltimo, al igual que en el programa estereodiagrama , se tiene en cuenta la subunidad marcada por el usuario para restringir los residuos que el usuario puede elegir.","title":"Aplicaci\u00f3n Free Pascal/Lazarus"},{"location":"alinearZ/#demostracion-de-uso","text":"Figura 1. Animaci\u00f3n del programa alinear_Z mostrando su uso.","title":"Demostraci\u00f3n de uso"},{"location":"alinearZ/#verificacion-con-pymol","text":"Por \u00faltimo, se pide que se compruebe la correcci\u00f3n de la transformaci\u00f3n realizada empleando un programa de visualizaci\u00f3n de prote\u00ednas. Mostramos a continuaci\u00f3n la imagen resultante de alinear los residuos 35 a 43 de la prote\u00edna 2AFM con nuestro programa: Figura 2. Proyecci\u00f3n sobre el plano de los residuos 35 a 43 de la prote\u00edna 2AFM, mostrando las coordenadas \\(y\\) frente a \\(x\\) antes y despu\u00e9s de alinear. Figura 4. Visualizaci\u00f3n de los residuos 35 a 43 de la prote\u00edna 2AFM con PyMol despu\u00e9s de alinear manualmente el primer y \u00faltimo residuo del fragmento. Como se puede observar, el programa desarrollado funciona adecuadamente y es capaz, no solo de realizar las transformaciones pertinentes, sino, tambi\u00e9n, mostrarlas gr\u00e1ficamente, aunque sea de una forma rudimentaria.","title":"Verificaci\u00f3n con PyMol"},{"location":"bibliografia/","text":"Bibliograf\u00eda Arantes, P. R., Pol\u00eato, M. D., Pedebos, C., & Ligabue-Braun, R. (2021). Making it Rain: Cloud-Based Molecular Simulations for Everyone. Journal of Chemical Information and Modeling , 61 (10), 4852-4856. https://doi.org/10.1021/acs.jcim.1c00998 Coimbra, J. R. M., & Salvador, J. A. R. (2021). A patent review of glutaminyl cyclase inhibitors (2004\u2013present). Expert Opinion on Therapeutic Patents , 31 (9), 809-836. https://doi.org/10.1080/13543776.2021.1917549 Golden, M., Garc\u00eda-Portugu\u00e9s, E., S\u00f8rensen, M., Mardia, K. V., Hamelryck, T., & Hein, J. (2017). A Generative Angular Model of Protein Structure Evolution. Molecular Biology and Evolution , 34 (8), 2085-2100. https://doi.org/10.1093/molbev/msx137 Grant, B. J., Rodrigues, A. P. C., ElSawy, K. M., McCammon, J. A., & Caves, L. S. D. (2006). Bio3d: An R package for the comparative analysis of protein structures. Bioinformatics , 22 (21), 2695-2696. https://doi.org/10.1093/bioinformatics/btl461 Gunn, A. P., Wong, B. X., McLean, C., Fowler, C., Barnard, P. J., Duce, J. A., Roberts, B. R., & The AIBL Research Group. (2021). Increased glutaminyl cyclase activity in brains of Alzheimer\u2019s disease individuals. Journal of Neurochemistry , 156 (6), 979-987. https://doi.org/10.1111/jnc.15114 Hekkelman, M. L., de Vries, I., Joosten, R. P., & Perrakis, A. (2021). AlphaFill: Enriching the AlphaFold models with ligands and co-factors [Preprint]. Bioinformatics. https://doi.org/10.1101/2021.11.26.470110 Hollingsworth, S. A., & Dror, R. O. (2018). Molecular Dynamics Simulation for All. Neuron , 99 (6), 1129-1143. https://doi.org/10.1016/j.neuron.2018.08.011 Huang, K.-F., Huang, J.-S., Wu, M.-L., Hsieh, W.-L., Hsu, K.-C., Hsu, H.-L., Ko, T.-P., & Wang, A. H.-J. (2021). A Unique Carboxylic-Acid Hydrogen-Bond Network (CAHBN) Confers Glutaminyl Cyclase Activity on M28 Family Enzymes. Journal of Molecular Biology , 433 (13), 166960. https://doi.org/10.1016/j.jmb.2021.166960 Huang, K.-F., Liu, Y.-L., Cheng, W.-J., Ko, T.-P., & Wang, A. H.-J. (2005). Crystal structures of human glutaminyl cyclase, an enzyme responsible for protein N-terminal pyroglutamate formation. Proceedings of the National Academy of Sciences , 102 (37), 13117-13122. https://doi.org/10.1073/pnas.0504184102 Tomasello, G., Armenia, I., & Molla, G. (2020). The Protein Imager: A full-featured online molecular viewer interface with server-side HQ-rendering capabilities. Bioinformatics , 36 (9), 2909-2911. https://doi.org/10.1093/bioinformatics/btaa009 Trueblood, K. N., B\u00fcrgi, H. B., Burzlaff, H., Dunitz, J. D., Gramaccioli, C. M., Schulz, H. H., Shmueli, U., & Abrahams, S. C. (1996). Atomic Dispacement Parameter Nomenclature. Report of a Subcommittee on Atomic Displacement Parameter Nomenclature. Acta Crystallographica Section A Foundations of Crystallography , 52 (5), 770-781. https://doi.org/10.1107/S0108767396005697 Vijayan, D. K., & Zhang, K. Y. J. (2019). Human glutaminyl cyclase: Structure, function, inhibitors and involvement in Alzheimer\u2019s disease. Pharmacological Research , 147 , 104342. https://doi.org/10.1016/j.phrs.2019.104342","title":"Bibliografia"},{"location":"estereodiagrama/","text":"Estereodiagrama \u00b6 En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una aplicaci\u00f3n capaz de crear un estereodiagrama correspondiente a un fragmento definido de la prote\u00edna. El c\u00f3digo correspondiente a las funciones utilizadas para transformar (traslaci\u00f3n y giro) las coordenadas se encuentran en la librer\u00eda biotools/src_biotools y la aplicaci\u00f3n bajo el nombre de estereodiagrama . Este apartado se corresponde a la 7\u00aa actividad de la relaci\u00f3n de ejercicios. Funciones de transformaci\u00f3n \u00b6 En primer lugar, se desarrollaron una serie de funciones capaces de realizar transformaciones a un conjunto de coordenadas. Estas funciones, que fueron desarrolladas en clase, tienen distintas versiones sobrecargadas de manera que se pueda trasladar tanto un punto en el espacio, TPunto , un array din\u00e1mico TPuntos como un TPDB . En los siguientes bloques de c\u00f3digo se ha escogido una serie de funciones representativas de este peque\u00f1o m\u00f3dulo 'espacial' desarrollado. translacion() con TPunto translacion() con TPuntos translacion() con TPDB 1 2 3 4 5 6 7 8 9 function translacion ( dx , dy , dz : real ; V : Tpunto ) : Tpunto ; var S : Tpunto ; begin S . X := V . X + dx ; S . Y := V . Y + dy ; S . Z := V . Z + dz ; result := s ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 function translacion ( dx , dy , dz : real ; datos : Tpuntos ) : Tpuntos ; overload ; var s : Tpuntos ; j : integer ; begin setLength ( s , high ( datos ) + 1 ) ; for j := 0 to high ( datos ) do begin s [ j ] := translacion ( dx , dy , dz , datos [ j ]) ; end ; result := s ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 function translacion ( dx , dy , dz : real ; var p : TPDB ) : integer ; overload ; var j : integer ; begin for j := 1 to p . NumFichas do begin p . atm [ j ] . coor . x := p . atm [ j ] . coor . x + dx ; p . atm [ j ] . coor . y := p . atm [ j ] . coor . y + dy ; p . atm [ j ] . coor . z := p . atm [ j ] . coor . z + dz ; end ; result := 1 ; end ; Adem\u00e1s, se realiz\u00f3 la siguiente propuesta de mejora al c\u00f3digo desarrollado en clase para las funciones relativas a girar. Se trat\u00f3 de implementar una funci\u00f3n m\u00e1s gen\u00e9rica llamada girarTpuntos que recibiera tanto un \u00e1ngulo en radianes como una funci\u00f3n capaz de girar un vector en el espacio y que aplicara dicha transformaci\u00f3n a todos los vectores del array. Esta idea podr\u00eda ser implementada de forma m\u00e1s gen\u00e9rica con una funci\u00f3n que recibiese como argumentos el array a transformar y una funci\u00f3n transformadora y se obtendr\u00eda as\u00ed un c\u00f3digo m\u00e1s claro y conciso. Para escribir esta funci\u00f3n fue necesario definir una nueva clase llamada TTransformTPuntoFunc . Type TTransformTPuntoFunc girarTpuntos() GiroOZ() con TPunto GiroOX() con TPuntos GiroOY() con TPuntos 1 TTransformTPuntoFunc = function ( a : real ; X : TPunto ) : TPunto ; 1 2 3 4 5 6 7 8 9 10 11 12 function girarTpuntos ( rad : real ; datos : Tpuntos ; funcion_girar : TTransformTPuntoFunc ) : Tpuntos ; var s : Tpuntos ; j : integer ; begin setLength ( s , high ( datos ) + 1 ) ; for j := 0 to high ( datos ) do begin s [ j ] := funcion_girar ( rad , datos [ j ]) ; end ; result := s ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 13 function GiroOZ ( rad : real ; V : Tpunto ) : Tpunto ; var S : Tpunto ; seno , coseno : real ; begin seno := sin ( rad ) ; coseno := cos ( rad ) ; S . X := V . X * coseno - V . Y * seno ; S . Y := V . X * seno + V . Y * coseno ; S . Z := V . Z ; result := S ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 function GiroOX ( rad : real ; datos : Tpuntos ) : Tpuntos ; overload ; var s : Tpuntos ; j : integer ; begin setLength ( s , high ( datos ) + 1 ) ; for j := 0 to high ( datos ) do begin s [ j ] := GiroOX ( rad , datos [ j ]) ; end ; result := s ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 function GiroOY ( rad : real ; datos : Tpuntos ) : Tpuntos ; overload ; var s : Tpuntos ; j : integer ; begin setLength ( s , high ( datos ) + 1 ) ; for j := 0 to high ( datos ) do begin s [ j ] := GiroOY ( rad , datos [ j ]) ; end ; result := s ; end ; Estereodiagrama \u00b6 Un estereodiagrama es un tipo de representaci\u00f3n donde se muestra una imagen en dos dimensiones rotada en torno al eje Y (por defecto) un peque\u00f1o \u00e1ngulo (por defecto 5\u00ba) de manera que al visualizarse las dos una al lado de la otra se aprecie cierta tridimensionalidad. Aplicaci\u00f3n Free Pascal/Lazarus \u00b6 Nuestra aplicaci\u00f3n deber\u00e1 tener, entonces, una interfaz que permita al usuario seleccionar un fragmento de la prote\u00edna y un \u00e1ngulo de giro, as\u00ed como dos paneles donde se muestre gr\u00e1ficamente el resultado de la transformaci\u00f3n. Adem\u00e1s de esto, se han llevado a cabo las siguientes mejoras sobre lo realizado en clase: Opci\u00f3n para modificar el archivo en memoria y poder realizar as\u00ed transformaciones sucesivas. Opci\u00f3n para elegir el eje sobre el se va a girar. Restricci\u00f3n del rango de residuos que el usuario puede elegir como fragmento seg\u00fan la subunidad elegida. De esta manera, cuando el archivo PDB se carga en el programa, se actualiza el rango de subunidades que se pueden elegir y, cada vez que el usuario elige una nueva subunidad, los valores m\u00ednimos y m\u00e1ximos de las casillas de primer y \u00faltimo residuo se actualizan para que solo sean elegibles residuos de dicha subunidad. A continuaci\u00f3n, mostramos el procedimiento empleado para transformar las coordenadas espaciales iniciales seg\u00fan las indicaciones del usuario (o las coordenadas espaciales resultantes de la \u00faltima transformaci\u00f3n, si as\u00ed se indica). Hemos incluido este procedimiento porque nos parec\u00eda relevante mostrar un ejemplo de uso de la funci\u00f3n girarTpuntos() puesto que tiene ciertas peculiaridades en la sintaxis y para poder mostrar la soluci\u00f3n que encontramos para evitar posibles errores que pod\u00edan surgir al realizar transformaciones en memoria (si se cambiaba el array de TPuntos inicial o si todav\u00eda no se hab\u00eda definido). Procedure transformaci\u00f3n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Tprocedure TForm1 . Button2Click ( Sender : TObject ) ; var CA1 , CAn , subunidad , j : integer ; transfunct : TTransformTPuntoFunc ; begin Image1 . Canvas . Clear ; Image2 . Canvas . Clear ; CA1 := SpinEdit3 . Value ; CAn := SpinEdit4 . Value ; setLength ( V_CAInicial , CAn - CA1 + 1 ) ; setLength ( V_CATrans , CAn - CA1 + 1 ) ; setLength ( datos , 3 , CAn - CA1 + 1 ) ; //3 coordenadas for j := CA1 to CAn do V_CAInicial [ j - CA1 ] := p . atm [ p . res [ j ] . CA ] . coor ; for j := 0 to high ( V_CAInicial ) do begin datos [ 0 , j ] := V_CAInicial [ j ] . X ; datos [ 1 , j ] := V_CAInicial [ j ] . Y ; datos [ 2 , j ] := V_CAInicial [ j ] . Z ; end ; plotXY ( datos , image1 , SpinEdit6 . Value , SpinEdit7 . Value , TRUE , TRUE ) ; if ( SpinEdit1 . Value = 0 ) then transfunct :=@ GiroOX else if ( SpinEdit1 . Value = 1 ) then transfunct :=@ GiroOY else if ( SpinEdit1 . Value = 2 ) then transfunct :=@ GiroOZ ; if CheckBox1 . Checked and ( high ( V_CAInicial ) = high ( V_CATrans )) then V_CATrans := girarTpuntos ( SpinEdit2 . Value * pi / 180 , V_CATrans , transfunct ) else V_CATrans := girarTpuntos ( SpinEdit2 . Value * pi / 180 , V_CAInicial , transfunct ) ; for j := 0 to high ( V_CATrans ) do begin datos [ 0 , j ] := V_CATrans [ j ] . X ; datos [ 1 , j ] := V_CATrans [ j ] . Y ; datos [ 2 , j ] := V_CATrans [ j ] . Z ; end ; plotXY ( datos , image2 , SpinEdit6 . Value , SpinEdit7 . Value , TRUE , TRUE ) ; end Demostraci\u00f3n de uso \u00b6 A continuaci\u00f3n, mostramos el funcionamiento del programa con un fragmento de un \\(\\alpha\\) h\u00e9lice. Figura 1. Animaci\u00f3n del programa Estereodiagrama mostrando su uso. Verificaci\u00f3n con funci\u00f3n de visi\u00f3n estereosc\u00f3pica \u00b6 Por \u00faltimo, y para comprobar que nuestra representaci\u00f3n es correcta, vamos a comparar el estereodiagrama obtenido con la herramienta de visi\u00f3n estereosc\u00f3pica del programa PyMol. Mostramos a continuaci\u00f3n el estereodiagrama realizado con nuestra aplicaci\u00f3n Free Pascal/Lazarus: Figura 2. Estereodiagrama de los residuos 35 a 43 de la prote\u00edna 2AFM, mostrando las coordenadas \\(y\\) frente a \\(x\\) . La imagen de la derecha ha sido rotada 5\u00ba en el eje de la \\(y\\) respecto a la imagen de la izquierda. Por \u00faltimo, se muestran en la siguiente imagen una representaci\u00f3n de la cadena principal de los mismos residuos, 35 a 43, de la prote\u00edna 2AFM despu\u00e9s de aplicar la opci\u00f3n stereo crosseye del programa PyMol. Como se puede observar, aunque la orientaci\u00f3n no es exactamente la misma, se puede apreciar c\u00f3mo nuestro estereodiagrama se encuentra bien construido. Figura 3. Estereodiagrama realizado usando el programa PyMol para comprobar la calidad de nuestro estereodiagrama.","title":"Estereodiagrama"},{"location":"estereodiagrama/#estereodiagrama","text":"En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una aplicaci\u00f3n capaz de crear un estereodiagrama correspondiente a un fragmento definido de la prote\u00edna. El c\u00f3digo correspondiente a las funciones utilizadas para transformar (traslaci\u00f3n y giro) las coordenadas se encuentran en la librer\u00eda biotools/src_biotools y la aplicaci\u00f3n bajo el nombre de estereodiagrama . Este apartado se corresponde a la 7\u00aa actividad de la relaci\u00f3n de ejercicios.","title":"Estereodiagrama"},{"location":"estereodiagrama/#funciones-de-transformacion","text":"En primer lugar, se desarrollaron una serie de funciones capaces de realizar transformaciones a un conjunto de coordenadas. Estas funciones, que fueron desarrolladas en clase, tienen distintas versiones sobrecargadas de manera que se pueda trasladar tanto un punto en el espacio, TPunto , un array din\u00e1mico TPuntos como un TPDB . En los siguientes bloques de c\u00f3digo se ha escogido una serie de funciones representativas de este peque\u00f1o m\u00f3dulo 'espacial' desarrollado. translacion() con TPunto translacion() con TPuntos translacion() con TPDB 1 2 3 4 5 6 7 8 9 function translacion ( dx , dy , dz : real ; V : Tpunto ) : Tpunto ; var S : Tpunto ; begin S . X := V . X + dx ; S . Y := V . Y + dy ; S . Z := V . Z + dz ; result := s ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 function translacion ( dx , dy , dz : real ; datos : Tpuntos ) : Tpuntos ; overload ; var s : Tpuntos ; j : integer ; begin setLength ( s , high ( datos ) + 1 ) ; for j := 0 to high ( datos ) do begin s [ j ] := translacion ( dx , dy , dz , datos [ j ]) ; end ; result := s ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 function translacion ( dx , dy , dz : real ; var p : TPDB ) : integer ; overload ; var j : integer ; begin for j := 1 to p . NumFichas do begin p . atm [ j ] . coor . x := p . atm [ j ] . coor . x + dx ; p . atm [ j ] . coor . y := p . atm [ j ] . coor . y + dy ; p . atm [ j ] . coor . z := p . atm [ j ] . coor . z + dz ; end ; result := 1 ; end ; Adem\u00e1s, se realiz\u00f3 la siguiente propuesta de mejora al c\u00f3digo desarrollado en clase para las funciones relativas a girar. Se trat\u00f3 de implementar una funci\u00f3n m\u00e1s gen\u00e9rica llamada girarTpuntos que recibiera tanto un \u00e1ngulo en radianes como una funci\u00f3n capaz de girar un vector en el espacio y que aplicara dicha transformaci\u00f3n a todos los vectores del array. Esta idea podr\u00eda ser implementada de forma m\u00e1s gen\u00e9rica con una funci\u00f3n que recibiese como argumentos el array a transformar y una funci\u00f3n transformadora y se obtendr\u00eda as\u00ed un c\u00f3digo m\u00e1s claro y conciso. Para escribir esta funci\u00f3n fue necesario definir una nueva clase llamada TTransformTPuntoFunc . Type TTransformTPuntoFunc girarTpuntos() GiroOZ() con TPunto GiroOX() con TPuntos GiroOY() con TPuntos 1 TTransformTPuntoFunc = function ( a : real ; X : TPunto ) : TPunto ; 1 2 3 4 5 6 7 8 9 10 11 12 function girarTpuntos ( rad : real ; datos : Tpuntos ; funcion_girar : TTransformTPuntoFunc ) : Tpuntos ; var s : Tpuntos ; j : integer ; begin setLength ( s , high ( datos ) + 1 ) ; for j := 0 to high ( datos ) do begin s [ j ] := funcion_girar ( rad , datos [ j ]) ; end ; result := s ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 13 function GiroOZ ( rad : real ; V : Tpunto ) : Tpunto ; var S : Tpunto ; seno , coseno : real ; begin seno := sin ( rad ) ; coseno := cos ( rad ) ; S . X := V . X * coseno - V . Y * seno ; S . Y := V . X * seno + V . Y * coseno ; S . Z := V . Z ; result := S ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 function GiroOX ( rad : real ; datos : Tpuntos ) : Tpuntos ; overload ; var s : Tpuntos ; j : integer ; begin setLength ( s , high ( datos ) + 1 ) ; for j := 0 to high ( datos ) do begin s [ j ] := GiroOX ( rad , datos [ j ]) ; end ; result := s ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 function GiroOY ( rad : real ; datos : Tpuntos ) : Tpuntos ; overload ; var s : Tpuntos ; j : integer ; begin setLength ( s , high ( datos ) + 1 ) ; for j := 0 to high ( datos ) do begin s [ j ] := GiroOY ( rad , datos [ j ]) ; end ; result := s ; end ;","title":"Funciones de transformaci\u00f3n"},{"location":"estereodiagrama/#estereodiagrama_1","text":"Un estereodiagrama es un tipo de representaci\u00f3n donde se muestra una imagen en dos dimensiones rotada en torno al eje Y (por defecto) un peque\u00f1o \u00e1ngulo (por defecto 5\u00ba) de manera que al visualizarse las dos una al lado de la otra se aprecie cierta tridimensionalidad.","title":"Estereodiagrama"},{"location":"estereodiagrama/#aplicacion-free-pascallazarus","text":"Nuestra aplicaci\u00f3n deber\u00e1 tener, entonces, una interfaz que permita al usuario seleccionar un fragmento de la prote\u00edna y un \u00e1ngulo de giro, as\u00ed como dos paneles donde se muestre gr\u00e1ficamente el resultado de la transformaci\u00f3n. Adem\u00e1s de esto, se han llevado a cabo las siguientes mejoras sobre lo realizado en clase: Opci\u00f3n para modificar el archivo en memoria y poder realizar as\u00ed transformaciones sucesivas. Opci\u00f3n para elegir el eje sobre el se va a girar. Restricci\u00f3n del rango de residuos que el usuario puede elegir como fragmento seg\u00fan la subunidad elegida. De esta manera, cuando el archivo PDB se carga en el programa, se actualiza el rango de subunidades que se pueden elegir y, cada vez que el usuario elige una nueva subunidad, los valores m\u00ednimos y m\u00e1ximos de las casillas de primer y \u00faltimo residuo se actualizan para que solo sean elegibles residuos de dicha subunidad. A continuaci\u00f3n, mostramos el procedimiento empleado para transformar las coordenadas espaciales iniciales seg\u00fan las indicaciones del usuario (o las coordenadas espaciales resultantes de la \u00faltima transformaci\u00f3n, si as\u00ed se indica). Hemos incluido este procedimiento porque nos parec\u00eda relevante mostrar un ejemplo de uso de la funci\u00f3n girarTpuntos() puesto que tiene ciertas peculiaridades en la sintaxis y para poder mostrar la soluci\u00f3n que encontramos para evitar posibles errores que pod\u00edan surgir al realizar transformaciones en memoria (si se cambiaba el array de TPuntos inicial o si todav\u00eda no se hab\u00eda definido). Procedure transformaci\u00f3n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Tprocedure TForm1 . Button2Click ( Sender : TObject ) ; var CA1 , CAn , subunidad , j : integer ; transfunct : TTransformTPuntoFunc ; begin Image1 . Canvas . Clear ; Image2 . Canvas . Clear ; CA1 := SpinEdit3 . Value ; CAn := SpinEdit4 . Value ; setLength ( V_CAInicial , CAn - CA1 + 1 ) ; setLength ( V_CATrans , CAn - CA1 + 1 ) ; setLength ( datos , 3 , CAn - CA1 + 1 ) ; //3 coordenadas for j := CA1 to CAn do V_CAInicial [ j - CA1 ] := p . atm [ p . res [ j ] . CA ] . coor ; for j := 0 to high ( V_CAInicial ) do begin datos [ 0 , j ] := V_CAInicial [ j ] . X ; datos [ 1 , j ] := V_CAInicial [ j ] . Y ; datos [ 2 , j ] := V_CAInicial [ j ] . Z ; end ; plotXY ( datos , image1 , SpinEdit6 . Value , SpinEdit7 . Value , TRUE , TRUE ) ; if ( SpinEdit1 . Value = 0 ) then transfunct :=@ GiroOX else if ( SpinEdit1 . Value = 1 ) then transfunct :=@ GiroOY else if ( SpinEdit1 . Value = 2 ) then transfunct :=@ GiroOZ ; if CheckBox1 . Checked and ( high ( V_CAInicial ) = high ( V_CATrans )) then V_CATrans := girarTpuntos ( SpinEdit2 . Value * pi / 180 , V_CATrans , transfunct ) else V_CATrans := girarTpuntos ( SpinEdit2 . Value * pi / 180 , V_CAInicial , transfunct ) ; for j := 0 to high ( V_CATrans ) do begin datos [ 0 , j ] := V_CATrans [ j ] . X ; datos [ 1 , j ] := V_CATrans [ j ] . Y ; datos [ 2 , j ] := V_CATrans [ j ] . Z ; end ; plotXY ( datos , image2 , SpinEdit6 . Value , SpinEdit7 . Value , TRUE , TRUE ) ; end","title":"Aplicaci\u00f3n Free Pascal/Lazarus"},{"location":"estereodiagrama/#demostracion-de-uso","text":"A continuaci\u00f3n, mostramos el funcionamiento del programa con un fragmento de un \\(\\alpha\\) h\u00e9lice. Figura 1. Animaci\u00f3n del programa Estereodiagrama mostrando su uso.","title":"Demostraci\u00f3n de uso"},{"location":"estereodiagrama/#verificacion-con-funcion-de-vision-estereoscopica","text":"Por \u00faltimo, y para comprobar que nuestra representaci\u00f3n es correcta, vamos a comparar el estereodiagrama obtenido con la herramienta de visi\u00f3n estereosc\u00f3pica del programa PyMol. Mostramos a continuaci\u00f3n el estereodiagrama realizado con nuestra aplicaci\u00f3n Free Pascal/Lazarus: Figura 2. Estereodiagrama de los residuos 35 a 43 de la prote\u00edna 2AFM, mostrando las coordenadas \\(y\\) frente a \\(x\\) . La imagen de la derecha ha sido rotada 5\u00ba en el eje de la \\(y\\) respecto a la imagen de la izquierda. Por \u00faltimo, se muestran en la siguiente imagen una representaci\u00f3n de la cadena principal de los mismos residuos, 35 a 43, de la prote\u00edna 2AFM despu\u00e9s de aplicar la opci\u00f3n stereo crosseye del programa PyMol. Como se puede observar, aunque la orientaci\u00f3n no es exactamente la misma, se puede apreciar c\u00f3mo nuestro estereodiagrama se encuentra bien construido. Figura 3. Estereodiagrama realizado usando el programa PyMol para comprobar la calidad de nuestro estereodiagrama.","title":"Verificaci\u00f3n con funci\u00f3n de visi\u00f3n estereosc\u00f3pica"},{"location":"formato_ficheros/","text":"Extraer secuencia distintos formatos \u00b6 En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de un diagrama de flujo que permita identificar si un fichero tiene un formato EMBL, UniProt, GenBank, PDB o, si por el contrario, se encuentra en un formato no soportado. A partir de este diagrama y de las particularidades de cada formato se pide que se extraiga la secuencia de la prote\u00edna en cualquiera de estos 4 formatos de forma autom\u00e1tica. A continuaci\u00f3n se procede a mostrar de forma detallada el funcionamiento de la misma. El c\u00f3digo correspondiente a esta funcionalidad se puede encontrar en la librer\u00eda biotools/src_biotools y la implementaci\u00f3n en un programa con interfaz gr\u00e1fica en el repositorio bajo el nombre de extraer_secuencia . Este apartado se corresponde a la 2\u00aa actividad de la relaci\u00f3n de ejercicios. Diagrama de flujo \u00b6 En primer lugar, se consult\u00f3 la bibliograf\u00eda aportada y se realiz\u00f3 el siguiente diagrama de flujo, el cual de forma muy simplificada, muestra permitir\u00eda distinguir entre estos 4 formatos. La principal mejora que podr\u00eda hacerse a este programa ser\u00eda, precisamente, realizar un diagrama de flujo m\u00e1s complejo que tuviera en cuenta otras caracter\u00edsticas adem\u00e1s de la primera l\u00ednea del archivo. As\u00ed, podr\u00edan detectarse archivos mal formateados. Figura 1. Diagrama de flujo para discriminar formato ficheros y extracci\u00f3n de secuencias. Elaboraci\u00f3n propia. Identificaci\u00f3n del formato \u00b6 Para realizar este programa se han realizado una serie de funciones que identifican, en base al diagrama de flujo anterior, el formato del archivo. Adem\u00e1s, se ha utilizado la clase de Pascal class(TTestCase) para automatizar la realizaci\u00f3n de los test de este programa. Este desarrollo \"modular\" en base a funciones y acompa\u00f1ado de test es muy conveniente porque en caso de querer ampliar este programa a otros formatos, o mejorar los preexistentes, se puede trabajar en peque\u00f1as unidades de c\u00f3digo que funcionan independientemente y que se testean autom\u00e1ticamente. Destacar que otra ventaja es la reutilizaci\u00f3n. La funci\u00f3n isPDB , por ejemplo, fue a\u00f1adida al inicio de las funciones que trabajaban con archivos de formato PDB. Las funciones escritas para identificar los formatos de los archivos son las siguientes: isEmbl() isUniProt() isGenBank() isPDB() 1 2 3 4 5 function isEmbl ( archivo : Tstrings ) : boolean ; begin if ( copy ( archivo [ 0 ] , 0 , 2 ) = 'ID' ) and ( copy ( archivo [ 1 ] , 0 , 2 ) = 'XX' ) then result := TRUE else result := FALSE ; end ; 1 2 3 4 5 function isUniProt ( archivo : Tstrings ) : boolean ; begin if ( copy ( archivo [ 0 ] , 0 , 2 ) = 'ID' ) and ( copy ( archivo [ 1 ] , 0 , 2 ) = 'AC' ) then result := TRUE else result := FALSE ; end ; 1 2 3 4 5 function isGenBank ( archivo : Tstrings ) : boolean ; begin if ( copy ( archivo [ 0 ] , 0 , 5 ) = 'LOCUS' ) then result := TRUE else result := FALSE ; end ; 1 2 3 4 5 function isPDB ( archivo : Tstrings ) : boolean ; begin if ( copy ( archivo [ 0 ] , 0 , 6 ) = 'HEADER' ) then result := TRUE else result := FALSE ; end ; Leer secuencia de prote\u00edna \u00b6 A continuaci\u00f3n, se muestra la funci\u00f3n que se escribi\u00f3 para extraer la secuencia de la prote\u00edna en cada uno de los formatos anteriores. Para escribirla se tuvo en cuenta las peculiaridades de cada formato en cuanto a d\u00f3nde se encontraba la secuencia y, en el caso del archivo PDB, se utiliz\u00f3 la funci\u00f3n cargarPDB que ya hab\u00eda sido desarrollada para el ejercicio siguiente. Funci\u00f3n leerSecuenciaProteina 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 function leerSecuenciaProteina ( archivo : Tstrings ) : AnsiString ; var j , i : integer ; sec , linea : String ; p : TPDB ; check : boolean ; begin if ( isPDB ( archivo )) then begin p := CargarPDB ( archivo ) ; result := p . secuencia ; ShowMessage ( 'Se ha detectado un archivo en formato PDB' ) ; end else if ( isGenBank ( archivo )) then begin sec := '' ; for j := 0 to archivo . count - 1 do begin linea := archivo [ j ] ; if copy ( linea , 0 , 6 ) = 'ORIGIN' then Break ; sec := sec + trim ( linea ) ; if copy ( linea , 22 , 13 ) = '/translation=' then sec := copy ( linea , 35 , 70 ) ; end ; result := trim ( copy ( sec , 2 , sec . Length - 2 )) ; ShowMessage ( 'Se ha detectado un archivo en formato GenBank' ) ; end else if ( isUniProt ( archivo )) then begin for j := 0 to archivo . count - 1 do begin linea := archivo [ j ] ; if copy ( linea , 0 , 2 ) = '//' then Break ; sec := sec + trim ( linea ) ; if copy ( linea , 0 , 2 ) = 'SQ' then sec := '' ; end ; result := trim ( sec ) ; ShowMessage ( 'Se ha detectado un archivo en formato UniProt' ) ; end else if ( isEmbl ( archivo )) then begin sec := '' ; check := FALSE ; for j := 0 to archivo . count - 1 do begin linea := archivo [ j ] ; if ( copy ( linea , 0 , 2 ) = 'XX' ) AND check then Break ; sec := sec + trim ( copy ( linea , 22 , 58 )) ; if copy ( linea , 22 , 13 ) = '/translation=' then begin check := TRUE ; sec := copy ( linea , 35 , 39 ) ; end ; end ; result := trim ( copy ( sec , 2 , sec . Length - 2 )) ; ShowMessage ( 'Se ha detectado un archivo en formato EMBL' ) ; end else ShowMessage ( 'Es un formato no soportado' ) ; end ; TTestCase \u00b6 Para la realizaci\u00f3n de los test empleados para este programa, se hizo uso de la clase TTestCase y del framework para unit testing fpcunit soportado por Lazarus. A continuaci\u00f3n, mostramos a modo de ejemplo el c\u00f3digo correspondiente para el procedimiento Embl , que realiza los test para las funciones relativas a este formato. El esquema seguido en este procedimiento es id\u00e9ntico al resto: Se cargan en variables tipo TStringList un archivo \"modelo\" para cada tipo de formato. Se comprueba si el comportamiento de la funci\u00f3n isFormato() es el esperado, es decir, que devuelve un valor True cuando se le da como argumento el fichero de dicho formato y un valor False para el resto. Se comprueba que la secuencia que devuelve la funci\u00f3n leerSecuenciaProteina es exactamente la esperada. testing_biotools.Embl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 procedure testing_biotools . Embl ; var SL_embl : TStringList ; SL_pdb : TStringList ; SL_UniProt : TStringList ; SL_GenBank : TStringList ; sec1 , sec2 : String ; begin SL_embl := TStringList . Create ; SL_pdb := TStringList . Create ; SL_UniProt := TStringList . Create ; SL_GenBank := TStringList . Create ; SL_embl . LoadFromFile ( 'text_embl.txt' ) ; SL_pdb . LoadFromFile ( 'text_PDB.txt' ) ; SL_UniProt . LoadFromFile ( 'text_UniProt.txt' ) ; SL_GenBank . LoadFromFile ( 'text_GenBank.txt' ) ; IF not isEmbl ( SL_embl ) THEN Fail ( 'No se ha detectado correctamente el archivo formato EMBL' ) ; IF isEmbl ( SL_pdb ) THEN Fail ( 'Se ha detectado err\u00f3neamente el formato EMBL con un pdb' ) ; IF isEmbl ( SL_UniProt ) THEN Fail ( 'Se ha detectado err\u00f3neamente el formato EMBL con un UniProt' ) ; IF isEmbl ( SL_GenBank ) THEN Fail ( 'Se ha detectado err\u00f3neamente el formato EMBL con un GenBank' ) ; sec1 := 'MDFIVAIFALFVISSFTITSTNAVEASTLLDIGNLSRS' + 'SFPRGFIFGAGSSAYQFEGAVNEGGRGPSIWDTFTHKYPEKIRDGSNADITV' + 'DQYHRYKEDVGIMKDQNMDSYRFSISWPRILPKGKLSGGINHEGIKYYNNLI' + 'NELLANGIQPFVTLFHWDLPQVLEDEYGGFLNSGVINDFRDYTDLCFKEFGD' + 'RVRYWSTLNEPWVFSNSGYALGTNAPGRCSASNVAKPGDSGTGPYIVTHNQI' + 'LAHAEAVHVYKTKYQAYQKGKIGITLVSNWLMPLDDNSIPDIKAAERSLDFQ' + 'FGLFMEQLTTGDYSKSMRRIVKNRLPKFSKFESSLVNGSFDFIGINYYSSSY' + 'ISNAPSHGNAKPSYSTNPMTNISFEKHGIPLGPRAASIWIYVYPYMFIQEDF' + 'EIFCYILKINITILQFSITENGMNEFNDATLPVEEALLNTYRIDYYYRHLYY' + 'IRSAIRAGSNVKGFYAWSFLDCNEWFAGFTVRFGLNFVD' ; sec2 := leerSecuenciaProteina ( SL_embl ) ; IF not ( sec2 = sec1 ) THEN Fail ( 'No se ha le\u00eddo la secuencia correctamente' ) ; end ; Demostraci\u00f3n de uso \u00b6 Por \u00faltimo, se muestra una peque\u00f1a animaci\u00f3n donde se muestra la implementaci\u00f3n en una interfaz gr\u00e1fica del c\u00f3digo anterior. Figura 2. Animaci\u00f3n con ejemplo de uso de la aplicaci\u00f3n extraer secuencias.","title":"Extraer secuencia distintos formatos"},{"location":"formato_ficheros/#extraer-secuencia-distintos-formatos","text":"En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de un diagrama de flujo que permita identificar si un fichero tiene un formato EMBL, UniProt, GenBank, PDB o, si por el contrario, se encuentra en un formato no soportado. A partir de este diagrama y de las particularidades de cada formato se pide que se extraiga la secuencia de la prote\u00edna en cualquiera de estos 4 formatos de forma autom\u00e1tica. A continuaci\u00f3n se procede a mostrar de forma detallada el funcionamiento de la misma. El c\u00f3digo correspondiente a esta funcionalidad se puede encontrar en la librer\u00eda biotools/src_biotools y la implementaci\u00f3n en un programa con interfaz gr\u00e1fica en el repositorio bajo el nombre de extraer_secuencia . Este apartado se corresponde a la 2\u00aa actividad de la relaci\u00f3n de ejercicios.","title":"Extraer secuencia distintos formatos"},{"location":"formato_ficheros/#diagrama-de-flujo","text":"En primer lugar, se consult\u00f3 la bibliograf\u00eda aportada y se realiz\u00f3 el siguiente diagrama de flujo, el cual de forma muy simplificada, muestra permitir\u00eda distinguir entre estos 4 formatos. La principal mejora que podr\u00eda hacerse a este programa ser\u00eda, precisamente, realizar un diagrama de flujo m\u00e1s complejo que tuviera en cuenta otras caracter\u00edsticas adem\u00e1s de la primera l\u00ednea del archivo. As\u00ed, podr\u00edan detectarse archivos mal formateados. Figura 1. Diagrama de flujo para discriminar formato ficheros y extracci\u00f3n de secuencias. Elaboraci\u00f3n propia.","title":"Diagrama de flujo"},{"location":"formato_ficheros/#identificacion-del-formato","text":"Para realizar este programa se han realizado una serie de funciones que identifican, en base al diagrama de flujo anterior, el formato del archivo. Adem\u00e1s, se ha utilizado la clase de Pascal class(TTestCase) para automatizar la realizaci\u00f3n de los test de este programa. Este desarrollo \"modular\" en base a funciones y acompa\u00f1ado de test es muy conveniente porque en caso de querer ampliar este programa a otros formatos, o mejorar los preexistentes, se puede trabajar en peque\u00f1as unidades de c\u00f3digo que funcionan independientemente y que se testean autom\u00e1ticamente. Destacar que otra ventaja es la reutilizaci\u00f3n. La funci\u00f3n isPDB , por ejemplo, fue a\u00f1adida al inicio de las funciones que trabajaban con archivos de formato PDB. Las funciones escritas para identificar los formatos de los archivos son las siguientes: isEmbl() isUniProt() isGenBank() isPDB() 1 2 3 4 5 function isEmbl ( archivo : Tstrings ) : boolean ; begin if ( copy ( archivo [ 0 ] , 0 , 2 ) = 'ID' ) and ( copy ( archivo [ 1 ] , 0 , 2 ) = 'XX' ) then result := TRUE else result := FALSE ; end ; 1 2 3 4 5 function isUniProt ( archivo : Tstrings ) : boolean ; begin if ( copy ( archivo [ 0 ] , 0 , 2 ) = 'ID' ) and ( copy ( archivo [ 1 ] , 0 , 2 ) = 'AC' ) then result := TRUE else result := FALSE ; end ; 1 2 3 4 5 function isGenBank ( archivo : Tstrings ) : boolean ; begin if ( copy ( archivo [ 0 ] , 0 , 5 ) = 'LOCUS' ) then result := TRUE else result := FALSE ; end ; 1 2 3 4 5 function isPDB ( archivo : Tstrings ) : boolean ; begin if ( copy ( archivo [ 0 ] , 0 , 6 ) = 'HEADER' ) then result := TRUE else result := FALSE ; end ;","title":"Identificaci\u00f3n del formato"},{"location":"formato_ficheros/#leer-secuencia-de-proteina","text":"A continuaci\u00f3n, se muestra la funci\u00f3n que se escribi\u00f3 para extraer la secuencia de la prote\u00edna en cada uno de los formatos anteriores. Para escribirla se tuvo en cuenta las peculiaridades de cada formato en cuanto a d\u00f3nde se encontraba la secuencia y, en el caso del archivo PDB, se utiliz\u00f3 la funci\u00f3n cargarPDB que ya hab\u00eda sido desarrollada para el ejercicio siguiente. Funci\u00f3n leerSecuenciaProteina 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 function leerSecuenciaProteina ( archivo : Tstrings ) : AnsiString ; var j , i : integer ; sec , linea : String ; p : TPDB ; check : boolean ; begin if ( isPDB ( archivo )) then begin p := CargarPDB ( archivo ) ; result := p . secuencia ; ShowMessage ( 'Se ha detectado un archivo en formato PDB' ) ; end else if ( isGenBank ( archivo )) then begin sec := '' ; for j := 0 to archivo . count - 1 do begin linea := archivo [ j ] ; if copy ( linea , 0 , 6 ) = 'ORIGIN' then Break ; sec := sec + trim ( linea ) ; if copy ( linea , 22 , 13 ) = '/translation=' then sec := copy ( linea , 35 , 70 ) ; end ; result := trim ( copy ( sec , 2 , sec . Length - 2 )) ; ShowMessage ( 'Se ha detectado un archivo en formato GenBank' ) ; end else if ( isUniProt ( archivo )) then begin for j := 0 to archivo . count - 1 do begin linea := archivo [ j ] ; if copy ( linea , 0 , 2 ) = '//' then Break ; sec := sec + trim ( linea ) ; if copy ( linea , 0 , 2 ) = 'SQ' then sec := '' ; end ; result := trim ( sec ) ; ShowMessage ( 'Se ha detectado un archivo en formato UniProt' ) ; end else if ( isEmbl ( archivo )) then begin sec := '' ; check := FALSE ; for j := 0 to archivo . count - 1 do begin linea := archivo [ j ] ; if ( copy ( linea , 0 , 2 ) = 'XX' ) AND check then Break ; sec := sec + trim ( copy ( linea , 22 , 58 )) ; if copy ( linea , 22 , 13 ) = '/translation=' then begin check := TRUE ; sec := copy ( linea , 35 , 39 ) ; end ; end ; result := trim ( copy ( sec , 2 , sec . Length - 2 )) ; ShowMessage ( 'Se ha detectado un archivo en formato EMBL' ) ; end else ShowMessage ( 'Es un formato no soportado' ) ; end ;","title":"Leer secuencia de prote\u00edna"},{"location":"formato_ficheros/#ttestcase","text":"Para la realizaci\u00f3n de los test empleados para este programa, se hizo uso de la clase TTestCase y del framework para unit testing fpcunit soportado por Lazarus. A continuaci\u00f3n, mostramos a modo de ejemplo el c\u00f3digo correspondiente para el procedimiento Embl , que realiza los test para las funciones relativas a este formato. El esquema seguido en este procedimiento es id\u00e9ntico al resto: Se cargan en variables tipo TStringList un archivo \"modelo\" para cada tipo de formato. Se comprueba si el comportamiento de la funci\u00f3n isFormato() es el esperado, es decir, que devuelve un valor True cuando se le da como argumento el fichero de dicho formato y un valor False para el resto. Se comprueba que la secuencia que devuelve la funci\u00f3n leerSecuenciaProteina es exactamente la esperada. testing_biotools.Embl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 procedure testing_biotools . Embl ; var SL_embl : TStringList ; SL_pdb : TStringList ; SL_UniProt : TStringList ; SL_GenBank : TStringList ; sec1 , sec2 : String ; begin SL_embl := TStringList . Create ; SL_pdb := TStringList . Create ; SL_UniProt := TStringList . Create ; SL_GenBank := TStringList . Create ; SL_embl . LoadFromFile ( 'text_embl.txt' ) ; SL_pdb . LoadFromFile ( 'text_PDB.txt' ) ; SL_UniProt . LoadFromFile ( 'text_UniProt.txt' ) ; SL_GenBank . LoadFromFile ( 'text_GenBank.txt' ) ; IF not isEmbl ( SL_embl ) THEN Fail ( 'No se ha detectado correctamente el archivo formato EMBL' ) ; IF isEmbl ( SL_pdb ) THEN Fail ( 'Se ha detectado err\u00f3neamente el formato EMBL con un pdb' ) ; IF isEmbl ( SL_UniProt ) THEN Fail ( 'Se ha detectado err\u00f3neamente el formato EMBL con un UniProt' ) ; IF isEmbl ( SL_GenBank ) THEN Fail ( 'Se ha detectado err\u00f3neamente el formato EMBL con un GenBank' ) ; sec1 := 'MDFIVAIFALFVISSFTITSTNAVEASTLLDIGNLSRS' + 'SFPRGFIFGAGSSAYQFEGAVNEGGRGPSIWDTFTHKYPEKIRDGSNADITV' + 'DQYHRYKEDVGIMKDQNMDSYRFSISWPRILPKGKLSGGINHEGIKYYNNLI' + 'NELLANGIQPFVTLFHWDLPQVLEDEYGGFLNSGVINDFRDYTDLCFKEFGD' + 'RVRYWSTLNEPWVFSNSGYALGTNAPGRCSASNVAKPGDSGTGPYIVTHNQI' + 'LAHAEAVHVYKTKYQAYQKGKIGITLVSNWLMPLDDNSIPDIKAAERSLDFQ' + 'FGLFMEQLTTGDYSKSMRRIVKNRLPKFSKFESSLVNGSFDFIGINYYSSSY' + 'ISNAPSHGNAKPSYSTNPMTNISFEKHGIPLGPRAASIWIYVYPYMFIQEDF' + 'EIFCYILKINITILQFSITENGMNEFNDATLPVEEALLNTYRIDYYYRHLYY' + 'IRSAIRAGSNVKGFYAWSFLDCNEWFAGFTVRFGLNFVD' ; sec2 := leerSecuenciaProteina ( SL_embl ) ; IF not ( sec2 = sec1 ) THEN Fail ( 'No se ha le\u00eddo la secuencia correctamente' ) ; end ;","title":"TTestCase"},{"location":"formato_ficheros/#demostracion-de-uso","text":"Por \u00faltimo, se muestra una peque\u00f1a animaci\u00f3n donde se muestra la implementaci\u00f3n en una interfaz gr\u00e1fica del c\u00f3digo anterior. Figura 2. Animaci\u00f3n con ejemplo de uso de la aplicaci\u00f3n extraer secuencias.","title":"Demostraci\u00f3n de uso"},{"location":"parser_PDB/","text":"Parseador ficheros PDB \u00b6 En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una funci\u00f3n, CargarPDB, capaz de parsear la informaci\u00f3n estructural relevante de un archivo PDB y almacenarla en una estructura matricial. Esta funci\u00f3n ha sido realizada durante el transcurso de la asignatura y es uno de los elementos claves del entorno de trabajo que hemos desarrollado durante el semestre. A continuaci\u00f3n se procede a mostrar de forma detallada el funcionamiento de la misma. El c\u00f3digo correspondiente a esta funcionalidad se puede encontrar en la librer\u00eda biotools/src_biotools . Por \u00faltimo, aclarar que para la explicaci\u00f3n no se seguir\u00e1 el orden cronol\u00f3gico en que se program\u00f3 (el cu\u00e1l podr\u00eda consultarse siguiendo los commits del repositorio) sino el orden l\u00f3gico de este. Este apartado se corresponde a la 3\u00aa actividad de la relaci\u00f3n de ejercicios. Records y Arrays \u00b6 En primer lugar, se definieron una serie de records que nos permitieran almacenar la informaci\u00f3n de forma ordenada y de vectores din\u00e1micos, dynamic arrays, para almacenar estos. Un record en pascal es un tipo de dato altamente estructurado y que consiste en la agrupaci\u00f3n de elementos de distinto tipo. Un array es un tipo que agrupa variables del mismo tipo. Utilizamos vectores din\u00e1micos cuando no es posible conocer el n\u00famero exacto de elementos necesarios, por lo ser\u00e1 necesario definir el tama\u00f1o de las mismas durante la ejecuci\u00f3n del programa. Se defini\u00f3 un record que contuviera la informaci\u00f3n relativa a un punto en el espacio, TPunto, y un array de puntos. Se defini\u00f3 un record que contuviera la informaci\u00f3n relativa a un \u00e1tomo de un archivo PDB en el espacio. La informaci\u00f3n que se consider\u00f3 fue la siguiente como relevante fue la siguiente. Destacar que la informaci\u00f3n relativa a las coordenadas se almacena en un TPunto. Se defini\u00f3 un record que contuviera la informaci\u00f3n relativa a un residuo de un archivo PDB, es decir, a una serie grupo de \u00e1tomos (de longitud variable) sobre los cu\u00e1les se pueden definir nuevas propiedades como \u00e1ngulos diedros. Por \u00faltimo, se definieron unos record con la informaci\u00f3n relativa a una subunidad de un archivo PDB y a un archivo PDB completo. Destacar que, en este caso, se opt\u00f3 por almacenar informaci\u00f3n redundante con el fin de simplificar el acceso a esta luego. Estos records constan de una serie de vectores din\u00e1micos que contienen TAtomPDB, TResiduoPDB, TSubunidadPDB y tambi\u00e9n de \u00edndices. TPunto TAtomPDB TResiduoPDB TsubunidadPDB TPDB 1 2 3 4 TPunto = record X , Y , Z : real ; end ; Tpuntos = array of Tpunto ; 1 2 3 4 5 6 7 8 9 TAtomPDB = record NumAtom : integer ; //N\u00famero de \u00e1tomo ID : string ; //Tipo de \u00e1tomo residuo : string ; //Residuo al que pertenece subunidad : char ; //Subunidad a la que pertenece NumRes : integer ; //N\u00famero de residuo coor : Tpunto ; //Coordenadas espaciales R : real ; //Factor temp end ; 1 2 3 4 5 6 7 8 9 TResiduoPDB = record // con los residuos phi , psi : real ; //\u00c1ngulos diedros NumRes : integer ; //N\u00famero de residuo subunidad : char ; //Subunidad a la que pertenece ID3 : string ; //Identificador residuo 3 letras ID1 : char ; //Identificador residuo 1 letra Atm1 , AtmN : integer ; //N\u00famero 1\u00ba y \u00faltimo \u00e1tomo N , CA , C , O : integer ; //N\u00famero \u00e1tomos esenciales de residuo end ; 1 2 3 4 5 6 TsubunidadPDB = record ID : char ; atm1 , atmN , res1 , resN : integer ; atomCount , resCount : integer ; ResIndex : array of integer ; end ; 1 2 3 4 5 6 7 8 9 TPDB = record header : string ; atm : array of TAtomPDB ; //array de records con informaci\u00f3n \u00e1tomos res : array of TResiduoPDB ; //array de records con informaci\u00f3n residuos sub : array of TsubunidadPDB ; //array de records con informaci\u00f3n subunidades NumFichas , NumResiduos : integer ; //N\u00famero de \u00e1tomos y residuos NumSubunidades : integer ; //N\u00famero de subunidades subs , secuencia : string ; //Strings caracteres subunidades y secuencia end ; C\u00e1lculo \u00e1ngulos de torsi\u00f3n \u00b6 El c\u00e1lculo de \u00e1ngulos de torsi\u00f3n presentaba una mayor dificultad. En primer lugar, para facilitar el trabajo vectorial, se definieron nuevos operadores aritm\u00e9ticos y booleanos para el tipo TPunto. Por ejemplo, as\u00ed definimos algunos de ellos: Operadores geom\u00e9tricos src_biotools 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Operator + ( A , B : TPunto ) : Tpunto ; begin result . X := A . X + B . X ; result . Y := A . Y + B . Y ; result . Z := A . Z + B . Z ; end ; Operator * ( V : TPunto ; k : real ) : TPunto ; begin result . X := k * V . X ; result . Y := k * V . Y ; result . Z := k * V . Z ; end ; Operator = ( A , B : TPunto ) : boolean ; begin if ( A . X = B . X ) and ( A . Y = B . Y ) and ( A . Z = B . Z ) then result := True ; else result := False ; end ; Se defini\u00f3 una funci\u00f3n llamada torsi\u00f3n, que calculaba el \u00e1ngulo de torsi\u00f3n de 4 puntos en el espacio, teniendo en cuenta las convenciones de la IUPAC. C\u00e1lculo \u00e1ngulos diedros 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function torsion ( A , B , C , D : TPunto ) : real ; var BA , BC , CB , CD , V1 , V2 , P : TPunto ; diedro , diedro_IUPAC , denominador , cosenoGamma : real ; begin diedro_IUPAC := 0 ; BA := A - B ; BC := C - B ; CB := B - C ; CD := D - C ; V1 := prodVectorial ( BC , BA ) ; V2 := prodVectorial ( CD , CB ) ; diedro := angulo ( V1 , V2 ) ; P := prodVectorial ( V2 , V1 ) ; denominador := modulo ( P ) * modulo ( CB ) ; if denominador > 0 then begin cosenoGamma := P * CB / denominador ; if cosenoGamma > 0 then cosenoGamma := 1 else cosenoGamma :=- 1 ; end else diedro_IUPAC := maxfloat ; if diedro_IUPAC < maxfloat then diedro_IUPAC := diedro * cosenoGamma ; result := diedro_IUPAC ; end ; Cargar PDB \u00b6 La funci\u00f3n CargarPDB acepta como \u00fanico argumento un TStrings (texto contenido en un memo) y, de forma sistem\u00e1tica, recorre las l\u00edneas del archivo PDB, accediendo a la informaci\u00f3n relativa a cada \u00e1tomo, residuo y subunidad, y guard\u00e1ndola en un record dentro de un array. Para hacer esto se tuvo en cuenta que los archivos .pdb son archivos que siguen unas pautas de formato muy espec\u00edficas. Una vez recorrido el archivo .pdb, se recorre cada una de las subunidades y residuos del TPDB para definir los \u00e1ngulos diedros \\(\\psi\\) y \\(\\phi\\) . A continuaci\u00f3n, se muestra la funci\u00f3n CargarPDB: Funci\u00f3n CargarPDB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 function CargarPDB ( texto : TStrings ) : TPDB ; overload ; var p : TPDB ; linea : string ; j , k , F , R , S : integer ; resno : integer ; begin if isPDB ( texto ) = False then ShowMessage ( 'No es un archivo PDB' ) ; p . secuencia := '' ; F := 0 ; R := 0 ; S := 0 ; setlength ( p . atm , texto . count ) ; setlength ( p . res , texto . count ) ; setlength ( p . sub , texto . count ) ; for j := 0 to texto . count - 1 do begin linea := texto [ j ] ; if ( copy ( linea , 1 , 6 ) = 'ATOM ' ) then begin F := F + 1 ; p . atm [ F ] . NumAtom := strtoint ( trim ( copy ( linea , 7 , 5 ))) ; p . atm [ F ] . ID := trim ( copy ( linea , 13 , 4 )) ; p . atm [ F ] . Residuo := copy ( linea , 18 , 3 ) ; p . atm [ F ] . Subunidad := linea [ 22 ] ; p . atm [ F ] . NumRes := strtoint ( trim ( copy ( linea , 23 , 4 ))) ; p . atm [ F ] . coor . X := strtofloat ( trim ( copy ( linea , 31 , 8 ))) ; p . atm [ F ] . coor . Y := strtofloat ( trim ( copy ( linea , 39 , 8 ))) ; p . atm [ F ] . coor . Z := strtofloat ( trim ( copy ( linea , 47 , 8 ))) ; p . atm [ F ] . R := strtofloat ( trim ( copy ( linea , 61 , 6 ))) ; //Residuo if p . atm [ F ] . ID = 'N' then begin R := R + 1 ; p . res [ R ] . Atm1 := F ; p . res [ R ] . ID3 := p . atm [ F ] . Residuo ; p . res [ R ] . ID1 := AA3to1 ( p . res [ R ] . ID3 ) ; p . res [ R ] . N := F ; p . res [ R ] . NumRes := p . atm [ F ] . NumRes ; p . res [ R ] . Subunidad := p . atm [ F ] . Subunidad ; p . secuencia := p . secuencia + p . res [ R ] . ID1 ; //Subunidad if pos ( p . atm [ F ] . Subunidad , p . subs ) = 0 then begin S := S + 1 ; p . subs := p . subs + p . atm [ F ] . Subunidad ; p . sub [ S ] . ID := p . atm [ F ] . Subunidad ; p . sub [ S ] . atm1 := F ; p . sub [ S ] . res1 := R ; end ; end ; if p . atm [ F ] . ID = 'CA' then p . res [ R ] . CA := F ; if p . atm [ F ] . ID = 'C' then p . res [ R ] . C := F ; if p . atm [ F ] . ID = 'O' then p . res [ R ] . O := F ; p . res [ R ] . AtmN := F ; p . sub [ S ] . atmN := F ; p . sub [ S ] . resN := R ; end ; end ; setlength ( p . atm , F + 1 ) ; setlength ( p . res , R + 1 ) ; setlength ( p . sub , S + 1 ) ; p . NumFichas := F ; p . NumResiduos := R ; p . NumSubunidades := S ; for j := 1 to p . NumSubunidades do with p . sub [ j ] do begin AtomCount := atmN - atm1 + 1 ; ResCount := resN - res1 + 1 ; for k := p . sub [ j ] . res1 + 1 to p . sub [ j ] . resn - 1 do begin p . res [ k ] . phi := torsion ( p . atm [ p . res [ k - 1 ] . C ] . coor , p . atm [ p . res [ k ] . N ] . coor , p . atm [ p . res [ k ] . CA ] . coor , p . atm [ p . res [ k ] . C ] . coor ) ; p . res [ k ] . psi := torsion ( p . atm [ p . res [ k ] . N ] . coor , p . atm [ p . res [ k ] . CA ] . coor , p . atm [ p . res [ k ] . C ] . coor , p . atm [ p . res [ k + 1 ] . N ] . coor ) ; end ; setlength ( p . sub [ j ] . resindex , p . NumResiduos + 1 ) ; for k := 1 to p . sub [ j ] . ResCount do begin resno := p . sub [ j ] . res1 + k - 1 ; p . sub [ j ] . resindex [ p . res [ resno ] . numres ] := resno ; end ; end ; result := p ; end ; Versi\u00f3n sobrecargada \u00b6 Adem\u00e1s, se realiz\u00f3 una funci\u00f3n CargarPDB sobrecargada que facilitara el uso de esta funci\u00f3n dentro del entorno Lazarus y simplificara el c\u00f3digo. Se decidi\u00f3 hacer esto porque, siendo el aspecto central de la asignatura el estudio de archivos PDB, iba a ser muy utilizada. La versi\u00f3n sobrecargada es la siguiente. Funci\u00f3n CargarPDB overload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function cargarPDB ( var p : TPDB ) : string ; var dialogo : TOpenDialog ; textoPDB : TStrings ; begin dialogo := TOpenDialog . create ( application ) ; textoPDB := TStringlist . create ; if dialogo . execute then begin textoPDB . loadfromfile ( dialogo . filename ) ; if isPDB ( textoPDB ) = False then ShowMessage ( 'No es un archivo PDB' ) ; p := cargarPDB ( textoPDB ) ; result := dialogo . filename ; end else result := '' ; dialogo . free ; textoPDB . free ; end ;","title":"Parseador ficheros PDB"},{"location":"parser_PDB/#parseador-ficheros-pdb","text":"En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una funci\u00f3n, CargarPDB, capaz de parsear la informaci\u00f3n estructural relevante de un archivo PDB y almacenarla en una estructura matricial. Esta funci\u00f3n ha sido realizada durante el transcurso de la asignatura y es uno de los elementos claves del entorno de trabajo que hemos desarrollado durante el semestre. A continuaci\u00f3n se procede a mostrar de forma detallada el funcionamiento de la misma. El c\u00f3digo correspondiente a esta funcionalidad se puede encontrar en la librer\u00eda biotools/src_biotools . Por \u00faltimo, aclarar que para la explicaci\u00f3n no se seguir\u00e1 el orden cronol\u00f3gico en que se program\u00f3 (el cu\u00e1l podr\u00eda consultarse siguiendo los commits del repositorio) sino el orden l\u00f3gico de este. Este apartado se corresponde a la 3\u00aa actividad de la relaci\u00f3n de ejercicios.","title":"Parseador ficheros PDB"},{"location":"parser_PDB/#records-y-arrays","text":"En primer lugar, se definieron una serie de records que nos permitieran almacenar la informaci\u00f3n de forma ordenada y de vectores din\u00e1micos, dynamic arrays, para almacenar estos. Un record en pascal es un tipo de dato altamente estructurado y que consiste en la agrupaci\u00f3n de elementos de distinto tipo. Un array es un tipo que agrupa variables del mismo tipo. Utilizamos vectores din\u00e1micos cuando no es posible conocer el n\u00famero exacto de elementos necesarios, por lo ser\u00e1 necesario definir el tama\u00f1o de las mismas durante la ejecuci\u00f3n del programa. Se defini\u00f3 un record que contuviera la informaci\u00f3n relativa a un punto en el espacio, TPunto, y un array de puntos. Se defini\u00f3 un record que contuviera la informaci\u00f3n relativa a un \u00e1tomo de un archivo PDB en el espacio. La informaci\u00f3n que se consider\u00f3 fue la siguiente como relevante fue la siguiente. Destacar que la informaci\u00f3n relativa a las coordenadas se almacena en un TPunto. Se defini\u00f3 un record que contuviera la informaci\u00f3n relativa a un residuo de un archivo PDB, es decir, a una serie grupo de \u00e1tomos (de longitud variable) sobre los cu\u00e1les se pueden definir nuevas propiedades como \u00e1ngulos diedros. Por \u00faltimo, se definieron unos record con la informaci\u00f3n relativa a una subunidad de un archivo PDB y a un archivo PDB completo. Destacar que, en este caso, se opt\u00f3 por almacenar informaci\u00f3n redundante con el fin de simplificar el acceso a esta luego. Estos records constan de una serie de vectores din\u00e1micos que contienen TAtomPDB, TResiduoPDB, TSubunidadPDB y tambi\u00e9n de \u00edndices. TPunto TAtomPDB TResiduoPDB TsubunidadPDB TPDB 1 2 3 4 TPunto = record X , Y , Z : real ; end ; Tpuntos = array of Tpunto ; 1 2 3 4 5 6 7 8 9 TAtomPDB = record NumAtom : integer ; //N\u00famero de \u00e1tomo ID : string ; //Tipo de \u00e1tomo residuo : string ; //Residuo al que pertenece subunidad : char ; //Subunidad a la que pertenece NumRes : integer ; //N\u00famero de residuo coor : Tpunto ; //Coordenadas espaciales R : real ; //Factor temp end ; 1 2 3 4 5 6 7 8 9 TResiduoPDB = record // con los residuos phi , psi : real ; //\u00c1ngulos diedros NumRes : integer ; //N\u00famero de residuo subunidad : char ; //Subunidad a la que pertenece ID3 : string ; //Identificador residuo 3 letras ID1 : char ; //Identificador residuo 1 letra Atm1 , AtmN : integer ; //N\u00famero 1\u00ba y \u00faltimo \u00e1tomo N , CA , C , O : integer ; //N\u00famero \u00e1tomos esenciales de residuo end ; 1 2 3 4 5 6 TsubunidadPDB = record ID : char ; atm1 , atmN , res1 , resN : integer ; atomCount , resCount : integer ; ResIndex : array of integer ; end ; 1 2 3 4 5 6 7 8 9 TPDB = record header : string ; atm : array of TAtomPDB ; //array de records con informaci\u00f3n \u00e1tomos res : array of TResiduoPDB ; //array de records con informaci\u00f3n residuos sub : array of TsubunidadPDB ; //array de records con informaci\u00f3n subunidades NumFichas , NumResiduos : integer ; //N\u00famero de \u00e1tomos y residuos NumSubunidades : integer ; //N\u00famero de subunidades subs , secuencia : string ; //Strings caracteres subunidades y secuencia end ;","title":"Records y Arrays"},{"location":"parser_PDB/#calculo-angulos-de-torsion","text":"El c\u00e1lculo de \u00e1ngulos de torsi\u00f3n presentaba una mayor dificultad. En primer lugar, para facilitar el trabajo vectorial, se definieron nuevos operadores aritm\u00e9ticos y booleanos para el tipo TPunto. Por ejemplo, as\u00ed definimos algunos de ellos: Operadores geom\u00e9tricos src_biotools 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Operator + ( A , B : TPunto ) : Tpunto ; begin result . X := A . X + B . X ; result . Y := A . Y + B . Y ; result . Z := A . Z + B . Z ; end ; Operator * ( V : TPunto ; k : real ) : TPunto ; begin result . X := k * V . X ; result . Y := k * V . Y ; result . Z := k * V . Z ; end ; Operator = ( A , B : TPunto ) : boolean ; begin if ( A . X = B . X ) and ( A . Y = B . Y ) and ( A . Z = B . Z ) then result := True ; else result := False ; end ; Se defini\u00f3 una funci\u00f3n llamada torsi\u00f3n, que calculaba el \u00e1ngulo de torsi\u00f3n de 4 puntos en el espacio, teniendo en cuenta las convenciones de la IUPAC. C\u00e1lculo \u00e1ngulos diedros 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function torsion ( A , B , C , D : TPunto ) : real ; var BA , BC , CB , CD , V1 , V2 , P : TPunto ; diedro , diedro_IUPAC , denominador , cosenoGamma : real ; begin diedro_IUPAC := 0 ; BA := A - B ; BC := C - B ; CB := B - C ; CD := D - C ; V1 := prodVectorial ( BC , BA ) ; V2 := prodVectorial ( CD , CB ) ; diedro := angulo ( V1 , V2 ) ; P := prodVectorial ( V2 , V1 ) ; denominador := modulo ( P ) * modulo ( CB ) ; if denominador > 0 then begin cosenoGamma := P * CB / denominador ; if cosenoGamma > 0 then cosenoGamma := 1 else cosenoGamma :=- 1 ; end else diedro_IUPAC := maxfloat ; if diedro_IUPAC < maxfloat then diedro_IUPAC := diedro * cosenoGamma ; result := diedro_IUPAC ; end ;","title":"C\u00e1lculo \u00e1ngulos de torsi\u00f3n"},{"location":"parser_PDB/#cargar-pdb","text":"La funci\u00f3n CargarPDB acepta como \u00fanico argumento un TStrings (texto contenido en un memo) y, de forma sistem\u00e1tica, recorre las l\u00edneas del archivo PDB, accediendo a la informaci\u00f3n relativa a cada \u00e1tomo, residuo y subunidad, y guard\u00e1ndola en un record dentro de un array. Para hacer esto se tuvo en cuenta que los archivos .pdb son archivos que siguen unas pautas de formato muy espec\u00edficas. Una vez recorrido el archivo .pdb, se recorre cada una de las subunidades y residuos del TPDB para definir los \u00e1ngulos diedros \\(\\psi\\) y \\(\\phi\\) . A continuaci\u00f3n, se muestra la funci\u00f3n CargarPDB: Funci\u00f3n CargarPDB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 function CargarPDB ( texto : TStrings ) : TPDB ; overload ; var p : TPDB ; linea : string ; j , k , F , R , S : integer ; resno : integer ; begin if isPDB ( texto ) = False then ShowMessage ( 'No es un archivo PDB' ) ; p . secuencia := '' ; F := 0 ; R := 0 ; S := 0 ; setlength ( p . atm , texto . count ) ; setlength ( p . res , texto . count ) ; setlength ( p . sub , texto . count ) ; for j := 0 to texto . count - 1 do begin linea := texto [ j ] ; if ( copy ( linea , 1 , 6 ) = 'ATOM ' ) then begin F := F + 1 ; p . atm [ F ] . NumAtom := strtoint ( trim ( copy ( linea , 7 , 5 ))) ; p . atm [ F ] . ID := trim ( copy ( linea , 13 , 4 )) ; p . atm [ F ] . Residuo := copy ( linea , 18 , 3 ) ; p . atm [ F ] . Subunidad := linea [ 22 ] ; p . atm [ F ] . NumRes := strtoint ( trim ( copy ( linea , 23 , 4 ))) ; p . atm [ F ] . coor . X := strtofloat ( trim ( copy ( linea , 31 , 8 ))) ; p . atm [ F ] . coor . Y := strtofloat ( trim ( copy ( linea , 39 , 8 ))) ; p . atm [ F ] . coor . Z := strtofloat ( trim ( copy ( linea , 47 , 8 ))) ; p . atm [ F ] . R := strtofloat ( trim ( copy ( linea , 61 , 6 ))) ; //Residuo if p . atm [ F ] . ID = 'N' then begin R := R + 1 ; p . res [ R ] . Atm1 := F ; p . res [ R ] . ID3 := p . atm [ F ] . Residuo ; p . res [ R ] . ID1 := AA3to1 ( p . res [ R ] . ID3 ) ; p . res [ R ] . N := F ; p . res [ R ] . NumRes := p . atm [ F ] . NumRes ; p . res [ R ] . Subunidad := p . atm [ F ] . Subunidad ; p . secuencia := p . secuencia + p . res [ R ] . ID1 ; //Subunidad if pos ( p . atm [ F ] . Subunidad , p . subs ) = 0 then begin S := S + 1 ; p . subs := p . subs + p . atm [ F ] . Subunidad ; p . sub [ S ] . ID := p . atm [ F ] . Subunidad ; p . sub [ S ] . atm1 := F ; p . sub [ S ] . res1 := R ; end ; end ; if p . atm [ F ] . ID = 'CA' then p . res [ R ] . CA := F ; if p . atm [ F ] . ID = 'C' then p . res [ R ] . C := F ; if p . atm [ F ] . ID = 'O' then p . res [ R ] . O := F ; p . res [ R ] . AtmN := F ; p . sub [ S ] . atmN := F ; p . sub [ S ] . resN := R ; end ; end ; setlength ( p . atm , F + 1 ) ; setlength ( p . res , R + 1 ) ; setlength ( p . sub , S + 1 ) ; p . NumFichas := F ; p . NumResiduos := R ; p . NumSubunidades := S ; for j := 1 to p . NumSubunidades do with p . sub [ j ] do begin AtomCount := atmN - atm1 + 1 ; ResCount := resN - res1 + 1 ; for k := p . sub [ j ] . res1 + 1 to p . sub [ j ] . resn - 1 do begin p . res [ k ] . phi := torsion ( p . atm [ p . res [ k - 1 ] . C ] . coor , p . atm [ p . res [ k ] . N ] . coor , p . atm [ p . res [ k ] . CA ] . coor , p . atm [ p . res [ k ] . C ] . coor ) ; p . res [ k ] . psi := torsion ( p . atm [ p . res [ k ] . N ] . coor , p . atm [ p . res [ k ] . CA ] . coor , p . atm [ p . res [ k ] . C ] . coor , p . atm [ p . res [ k + 1 ] . N ] . coor ) ; end ; setlength ( p . sub [ j ] . resindex , p . NumResiduos + 1 ) ; for k := 1 to p . sub [ j ] . ResCount do begin resno := p . sub [ j ] . res1 + k - 1 ; p . sub [ j ] . resindex [ p . res [ resno ] . numres ] := resno ; end ; end ; result := p ; end ;","title":"Cargar PDB"},{"location":"parser_PDB/#version-sobrecargada","text":"Adem\u00e1s, se realiz\u00f3 una funci\u00f3n CargarPDB sobrecargada que facilitara el uso de esta funci\u00f3n dentro del entorno Lazarus y simplificara el c\u00f3digo. Se decidi\u00f3 hacer esto porque, siendo el aspecto central de la asignatura el estudio de archivos PDB, iba a ser muy utilizada. La versi\u00f3n sobrecargada es la siguiente. Funci\u00f3n CargarPDB overload 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function cargarPDB ( var p : TPDB ) : string ; var dialogo : TOpenDialog ; textoPDB : TStrings ; begin dialogo := TOpenDialog . create ( application ) ; textoPDB := TStringlist . create ; if dialogo . execute then begin textoPDB . loadfromfile ( dialogo . filename ) ; if isPDB ( textoPDB ) = False then ShowMessage ( 'No es un archivo PDB' ) ; p := cargarPDB ( textoPDB ) ; result := dialogo . filename ; end else result := '' ; dialogo . free ; textoPDB . free ; end ;","title":"Versi\u00f3n sobrecargada"},{"location":"ramachandran/","text":"Diagrama de Ramachandran \u00b6 En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una funci\u00f3n que permita obtener los \u00e1ngulos diedros de una prote\u00edna y su representaci\u00f3n en un diagrama de Ramachandran. Para la elaboraci\u00f3n de esta actividad se ha hecho uso del material impartido en clase en forma de apuntes. El c\u00f3digo correspondiente a esta funcionalidad se puede encontrar en la librer\u00eda biotools/src_biotools y la implementaci\u00f3n en un programa con interfaz gr\u00e1fica en el repositorio bajo el nombre de ramachandran . Este apartado se corresponde a la 6\u00aa actividad de la relaci\u00f3n de ejercicios. \u00c1ngulos de torsi\u00f3n \u00b6 Los \u00e1ngulos de torsi\u00f3n caracter\u00edsticos de una prote\u00edna son los \u00e1ngulos \\(\\psi\\) y \\(\\phi\\) y se pueden calcular para todos os residuos de una prote\u00edna excepto el primero y \u00faltimo. Figura 1. Representaci\u00f3n de los \u00e1ngulos de torsi\u00f3n (Golden et al., 2017) 1 . A continuaci\u00f3n, se muestran las funciones desarrolladas, angulo() y torsion() ,para calcular el \u00e1ngulo diedro (seg\u00fan las convenciones IUPAC de signo) para 4 puntos en el espacio (definidos en el record TPunto . Estas funciones se basan en que podemos calcular el \u00e1ngulo diedro formado por 4 puntos en el espacio, \\(A\\) , \\(B\\) , \\(C\\) y \\(D\\) , como el \u00e1ngulo que forman entre si los vectores \\(V_1\\) y \\(V_2\\) , resultantes del producto vectorial \\(\\vec{BC}\\times \\vec{BA}\\) y \\(\\vec{CD}\\times \\vec{CB}\\) , respectivamente. Adem\u00e1s, este \u00e1ngulo diedro debe de corregirse despu\u00e9s en signo para adecuarse a las convenciones IUPAC. angulo (A, B: Tpunto) angulo(A, B, C: TPunto) torsion ( A, B, C, D: TPunto) 1 2 3 4 5 6 7 8 9 function angulo ( A , B : Tpunto ) : real ; var denominador : real ; begin denominador := modulo ( A ) * modulo ( B ) ; if denominador > 0 then result := arccos ( A * B / denominador ) else result := maxfloat ; end ; 1 2 3 4 5 6 7 8 function angulo ( A , B , C : TPunto ) : real ; overload ; var BA , BC : TPunto ; begin BA := A - B ; BC := C - B ; result := angulo ( BA , BC ) ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function torsion ( A , B , C , D : TPunto ) : real ; var BA , BC , CB , CD , V1 , V2 , P : TPunto ; diedro , diedro_IUPAC , denominador , cosenoGamma : real ; begin diedro_IUPAC := 0 ; BA := A - B ; BC := C - B ; CB := B - C ; CD := D - C ; V1 := prodVectorial ( BC , BA ) ; V2 := prodVectorial ( CD , CB ) ; diedro := angulo ( V1 , V2 ) ; P := prodVectorial ( V2 , V1 ) ; denominador := modulo ( P ) * modulo ( CB ) ; if denominador > 0 then begin cosenoGamma := P * CB / denominador ; if cosenoGamma > 0 then cosenoGamma := 1 else cosenoGamma :=- 1 ; end else diedro_IUPAC := maxfloat ; if diedro_IUPAC < maxfloat then diedro_IUPAC := diedro * cosenoGamma ; result := diedro_IUPAC ; end ; Diagrama de Ramachandran \u00b6 Los diagramas de Ramachandran son representaciones de los \u00e1ngulos de torsi\u00f3n de los residuos de una prote\u00edna y son de gran inter\u00e9s puesto que es posible predecir la estructura secundaria de una prote\u00edna en base a los pares de valores \\(\\psi\\) y \\(\\phi\\) que tengan. Adem\u00e1s, nos da informaci\u00f3n sobre la calidad de una estructura tridimensional, puesto que valores que se alejen de aquellas zonas que se consideran \"normales\" son indicativo de un posible error en la estructura. Figura 2. Diagrama de Ramachandran. Obtenido de Wikipedia 2 . Aplicaci\u00f3n Free Pascal/Lazarus \u00b6 Para la realizaci\u00f3n de este programa fue necesario escribir la funci\u00f3n PlotXY utilizando la clase Canvas . No entraremos en detalles en el funcionamiento de esta funci\u00f3n puesto que fue desarrollada en clase. Adem\u00e1s, para obtener un gr\u00e1fico de mayor calidad y con ejes, utilizamos tambi\u00e9n la clase TChart que facilita la realizaci\u00f3n de gr\u00e1ficos. Hemos querido mantener el gr\u00e1fico original para mostrar c\u00f3mo nuestro 'm\u00f3dulo gr\u00e1fico' funciona de manera muy parecida a una clase desarrollada de manera rigurosa. El procedimiento empleado en el programa para realizar ambos gr\u00e1ficos y escribir los resultados en formato de de tabla se puede ver a continuaci\u00f3n: Procedimiento Diagrama de Ramachandran 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 procedure TForm1 . ButtonClick ( Sender : TObject ) ; var j , k , counter_col : integer ; datos : TTabladatos ; borrar : boolean ; begin memo2 . clear ; for j := 1 to p . NumSubunidades do begin counter_col := - 1 ; borrar := CheckBox1 . Checked ; setLength ( datos , 2 , p . sub [ j ] . resCount - 2 ) ; memo2 . visible := false ; Image1 . Visible := false ; if borrar then Chart1LineSeries1 . Clear () ; for k := p . sub [ j ] . res1 + 1 to p . sub [ j ] . resn - 1 do begin counter_col := counter_col + 1 ; memo2 . lines . add ( padright ( p . res [ k ] . ID3 + inttostr ( p . res [ k ] . NumRes ) + p . res [ k ] . subunidad , 10 ) + padleft ( formatfloat ( '#.##' , p . res [ k ] . phi * 180 / pi ) , 10 ) + padleft ( formatfloat ( '#.##' , p . res [ k ] . psi * 180 / pi ) , 10 )) ; datos [ 0 , counter_col ] := p . res [ k ] . phi * 180 / pi ; datos [ 1 , counter_col ] := p . res [ k ] . psi * 180 / pi ; // A\u00f1adimos a gr\u00e1fico con ejes Chart1LineSeries1 . AddXY ( datos [ 0 , counter_col ] , datos [ 1 , counter_col ] , '' , colorBox2 . Selected ) ; end ; plotXY ( datos , Image1 , 0 , //OX 1 , //OY borrar , //borrar false , //linea colorBox1 . Selected , //clpluma colorBox2 . Selected , //clrelleno colorBox3 . Selected ) ; //Tcolor memo2 . visible := true ; Image1 . Visible := true ; Chart1 . BottomAxis . Visible := TRUE ; Chart1 . BottomAxis . Visible := TRUE ; Chart1LineSeries1 . ShowPoints := TRUE ; Chart1LineSeries1 . LineType := ltNone ; end ; end ; Demostraci\u00f3n de uso \u00b6 A continuaci\u00f3n, se muestra en una animaci\u00f3n la implementaci\u00f3n de estas funciones en una interfaz gr\u00e1fica dentro del programa Ramachandran . Figura 3. Animaci\u00f3n del programa Ramachandran mostrando su uso. Comparaci\u00f3n de los \u00e1ngulos de torsi\u00f3n de distintas estructuras de hQC \u00b6 \u00c1ngulos de torsi\u00f3n de referencia \u00b6 En primer lugar, vamos a comparar los \u00e1ngulos de torsi\u00f3n calculados por nuestro programa con los valores de referencia que obtengamos por una aplicaci\u00f3n profesional. Por un lado, vamos a calcular los \u00e1ngulos de torsi\u00f3n para los residuos 34-40 de nuestra estructura 2AFM usando la aplicaci\u00f3n desarrollada. Y, por otro lado, vamos a emplear como referencia los \u00e1ngulos de torsi\u00f3n calculados por la aplicaci\u00f3n Torsion angles para la misma prote\u00edna. Como puede observarse en la Tabla 1, los valores son enormemente parecidos, diferenci\u00e1ndose \u00fanicamente debido a distintos criterios de redondeo. N\u00famero de residue Residuo \\(\\phi_{\\text{ref}}\\) \\(\\phi_{\\text{calculado}}\\) \\(\\psi_{\\text{ref}}\\) \\(\\psi_{\\text{calculado}}\\) 34 SER -41.80 -41.77 138.20 138.19 35 ALA -98.40 -98.42 22.50 22.48 36 TRP -59.90 -59.89 -31.10 -31.05 37 PRO -67.90 -67.86 -9.00 -9.03 38 GLU -89.60 -89.61 -10.40 -10.38 39 GLU -55.90 -55.90 -37.10 -37.10 40 LYS -56.70 -56.73 -28.00 -28.00 Tabla 1. Comparaci\u00f3n de los \u00e1ngulos de torsi\u00f3n calculados frente a un valor de referencia para la prote\u00edna 2AFM. Comparaci\u00f3n diagrama de Ramachandran \u00b6 En segundo lugar, vamos a comparar la estructura experimental 2AFW, que corresponde a la enzima hQC formando un complejo con N-acetilhistamina, uno de sus sustratos, con Q16769 de AlphaFold, que corresponde a la estructura nativa de la isoforma secretora. Para ello, hemos generado la siguiente representaci\u00f3n donde se muestran los residuos de 2AFW dibujados en azul y los de AlphaFold dibujados en blanco. En un principio, esperar\u00edamos que ambas estructuras fueran muy similares, pero se diferenciaran en unos pocos residuos: Aquellos residuos que forman la secuencia N-terminal de Q16769, responsable de su anclaje en el aparato de Golgi. Aquellos residuos que forman el sitio activo de la prote\u00edna y que est\u00e1 ligeramente m\u00e1s abierta en Q16769 que en 2AFW. Aquellos residuos de 2AFW que se hubieran visto afectados por la interacci\u00f3n de la enzima con su sustrato. Destacar que ser\u00eda interesante tambi\u00e9n comparar 2AFM (sin sustrato) con 2AFW (con sustrato) para poder \"aislar\" el efecto de la uni\u00f3n del sustrato a la enzima. Dicha imagen se puede observar en uno de los frames de la Figura 3, en la cual se puede ver c\u00f3mo ambos diagramas se superponen casi a la perfecci\u00f3n. Figura 4. Representaci\u00f3n esquem\u00e1tica del diagrama de Ramachandran para la prote\u00edna experimental 2AFM comparada con la prote\u00edna predecida por AlphaFold. En general, la agrupaci\u00f3n de los residuos dentro del diagrama concuerda con lo revisado en literatura a cerca de la estructura secundaria. Si comparamos la Figura 4 con la Figura 2, r\u00e1pidamente podemos ubicar los residuos que forman parte de hebras \\(\\beta\\) en la esquina superior izquierda, de h\u00e9lices \\(\\alpha\\) en el grupo de puntos debajo de este y en el lado derecho una nube de puntos que podr\u00eda corresponderse con h\u00e9lices con giro a la izquierda. Adem\u00e1s, la mayor parte de los puntos se encuentran en regiones no prohibidas est\u00e9ricamente, lo cual nos da una idea de la calidad de ambas estructuras. Conclusi\u00f3n \u00b6 En conclusi\u00f3n, el programa y las funciones desarrolladas son capaces de, en primer lugar, calcular los \u00e1ngulos de torsi\u00f3n para una estructura de forma adecuada y muy precisa, al compararla con herramientas profesionales. Y , en segundo lugar, la interfaz y el m\u00f3dulo gr\u00e1fico nos permiten analizar dichos resultados para comparar estructuras y , por ejemplo, observar el efecto que tiene en la estructura la uni\u00f3n de una mol\u00e9cula de inter\u00e9s biol\u00f3gico (como un sustrato o un inhibidor, para estudiar la cat\u00e1lisis enzim\u00e1tica). Esta idea tambi\u00e9n ser\u00eda aplicable para comparar las diferencias estructurales entre una prote\u00edna nativa y con alguna mutaci\u00f3n. Referencias \u00b6 Golden, M., Garc\u00eda-Portugu\u00e9s, E., S\u00f8rensen, M., Mardia, K. V., Hamelryck, T., & Hein, J. (2017). A Generative Angular Model of Protein Structure Evolution. Molecular Biology and Evolution, 34(8), 2085-2100. https://doi.org/10.1093/molbev/msx137 . \u21a9 Imagen elaborada por Dcrjsr y obtenida a trav\u00e9s de Wikipedia. \u21a9","title":"Diagrama de Ramachandran"},{"location":"ramachandran/#diagrama-de-ramachandran","text":"En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una funci\u00f3n que permita obtener los \u00e1ngulos diedros de una prote\u00edna y su representaci\u00f3n en un diagrama de Ramachandran. Para la elaboraci\u00f3n de esta actividad se ha hecho uso del material impartido en clase en forma de apuntes. El c\u00f3digo correspondiente a esta funcionalidad se puede encontrar en la librer\u00eda biotools/src_biotools y la implementaci\u00f3n en un programa con interfaz gr\u00e1fica en el repositorio bajo el nombre de ramachandran . Este apartado se corresponde a la 6\u00aa actividad de la relaci\u00f3n de ejercicios.","title":"Diagrama de Ramachandran"},{"location":"ramachandran/#angulos-de-torsion","text":"Los \u00e1ngulos de torsi\u00f3n caracter\u00edsticos de una prote\u00edna son los \u00e1ngulos \\(\\psi\\) y \\(\\phi\\) y se pueden calcular para todos os residuos de una prote\u00edna excepto el primero y \u00faltimo. Figura 1. Representaci\u00f3n de los \u00e1ngulos de torsi\u00f3n (Golden et al., 2017) 1 . A continuaci\u00f3n, se muestran las funciones desarrolladas, angulo() y torsion() ,para calcular el \u00e1ngulo diedro (seg\u00fan las convenciones IUPAC de signo) para 4 puntos en el espacio (definidos en el record TPunto . Estas funciones se basan en que podemos calcular el \u00e1ngulo diedro formado por 4 puntos en el espacio, \\(A\\) , \\(B\\) , \\(C\\) y \\(D\\) , como el \u00e1ngulo que forman entre si los vectores \\(V_1\\) y \\(V_2\\) , resultantes del producto vectorial \\(\\vec{BC}\\times \\vec{BA}\\) y \\(\\vec{CD}\\times \\vec{CB}\\) , respectivamente. Adem\u00e1s, este \u00e1ngulo diedro debe de corregirse despu\u00e9s en signo para adecuarse a las convenciones IUPAC. angulo (A, B: Tpunto) angulo(A, B, C: TPunto) torsion ( A, B, C, D: TPunto) 1 2 3 4 5 6 7 8 9 function angulo ( A , B : Tpunto ) : real ; var denominador : real ; begin denominador := modulo ( A ) * modulo ( B ) ; if denominador > 0 then result := arccos ( A * B / denominador ) else result := maxfloat ; end ; 1 2 3 4 5 6 7 8 function angulo ( A , B , C : TPunto ) : real ; overload ; var BA , BC : TPunto ; begin BA := A - B ; BC := C - B ; result := angulo ( BA , BC ) ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function torsion ( A , B , C , D : TPunto ) : real ; var BA , BC , CB , CD , V1 , V2 , P : TPunto ; diedro , diedro_IUPAC , denominador , cosenoGamma : real ; begin diedro_IUPAC := 0 ; BA := A - B ; BC := C - B ; CB := B - C ; CD := D - C ; V1 := prodVectorial ( BC , BA ) ; V2 := prodVectorial ( CD , CB ) ; diedro := angulo ( V1 , V2 ) ; P := prodVectorial ( V2 , V1 ) ; denominador := modulo ( P ) * modulo ( CB ) ; if denominador > 0 then begin cosenoGamma := P * CB / denominador ; if cosenoGamma > 0 then cosenoGamma := 1 else cosenoGamma :=- 1 ; end else diedro_IUPAC := maxfloat ; if diedro_IUPAC < maxfloat then diedro_IUPAC := diedro * cosenoGamma ; result := diedro_IUPAC ; end ;","title":"\u00c1ngulos de torsi\u00f3n"},{"location":"ramachandran/#diagrama-de-ramachandran_1","text":"Los diagramas de Ramachandran son representaciones de los \u00e1ngulos de torsi\u00f3n de los residuos de una prote\u00edna y son de gran inter\u00e9s puesto que es posible predecir la estructura secundaria de una prote\u00edna en base a los pares de valores \\(\\psi\\) y \\(\\phi\\) que tengan. Adem\u00e1s, nos da informaci\u00f3n sobre la calidad de una estructura tridimensional, puesto que valores que se alejen de aquellas zonas que se consideran \"normales\" son indicativo de un posible error en la estructura. Figura 2. Diagrama de Ramachandran. Obtenido de Wikipedia 2 .","title":"Diagrama de Ramachandran"},{"location":"ramachandran/#aplicacion-free-pascallazarus","text":"Para la realizaci\u00f3n de este programa fue necesario escribir la funci\u00f3n PlotXY utilizando la clase Canvas . No entraremos en detalles en el funcionamiento de esta funci\u00f3n puesto que fue desarrollada en clase. Adem\u00e1s, para obtener un gr\u00e1fico de mayor calidad y con ejes, utilizamos tambi\u00e9n la clase TChart que facilita la realizaci\u00f3n de gr\u00e1ficos. Hemos querido mantener el gr\u00e1fico original para mostrar c\u00f3mo nuestro 'm\u00f3dulo gr\u00e1fico' funciona de manera muy parecida a una clase desarrollada de manera rigurosa. El procedimiento empleado en el programa para realizar ambos gr\u00e1ficos y escribir los resultados en formato de de tabla se puede ver a continuaci\u00f3n: Procedimiento Diagrama de Ramachandran 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 procedure TForm1 . ButtonClick ( Sender : TObject ) ; var j , k , counter_col : integer ; datos : TTabladatos ; borrar : boolean ; begin memo2 . clear ; for j := 1 to p . NumSubunidades do begin counter_col := - 1 ; borrar := CheckBox1 . Checked ; setLength ( datos , 2 , p . sub [ j ] . resCount - 2 ) ; memo2 . visible := false ; Image1 . Visible := false ; if borrar then Chart1LineSeries1 . Clear () ; for k := p . sub [ j ] . res1 + 1 to p . sub [ j ] . resn - 1 do begin counter_col := counter_col + 1 ; memo2 . lines . add ( padright ( p . res [ k ] . ID3 + inttostr ( p . res [ k ] . NumRes ) + p . res [ k ] . subunidad , 10 ) + padleft ( formatfloat ( '#.##' , p . res [ k ] . phi * 180 / pi ) , 10 ) + padleft ( formatfloat ( '#.##' , p . res [ k ] . psi * 180 / pi ) , 10 )) ; datos [ 0 , counter_col ] := p . res [ k ] . phi * 180 / pi ; datos [ 1 , counter_col ] := p . res [ k ] . psi * 180 / pi ; // A\u00f1adimos a gr\u00e1fico con ejes Chart1LineSeries1 . AddXY ( datos [ 0 , counter_col ] , datos [ 1 , counter_col ] , '' , colorBox2 . Selected ) ; end ; plotXY ( datos , Image1 , 0 , //OX 1 , //OY borrar , //borrar false , //linea colorBox1 . Selected , //clpluma colorBox2 . Selected , //clrelleno colorBox3 . Selected ) ; //Tcolor memo2 . visible := true ; Image1 . Visible := true ; Chart1 . BottomAxis . Visible := TRUE ; Chart1 . BottomAxis . Visible := TRUE ; Chart1LineSeries1 . ShowPoints := TRUE ; Chart1LineSeries1 . LineType := ltNone ; end ; end ;","title":"Aplicaci\u00f3n Free Pascal/Lazarus"},{"location":"ramachandran/#demostracion-de-uso","text":"A continuaci\u00f3n, se muestra en una animaci\u00f3n la implementaci\u00f3n de estas funciones en una interfaz gr\u00e1fica dentro del programa Ramachandran . Figura 3. Animaci\u00f3n del programa Ramachandran mostrando su uso.","title":"Demostraci\u00f3n de uso"},{"location":"ramachandran/#comparacion-de-los-angulos-de-torsion-de-distintas-estructuras-de-hqc","text":"","title":"Comparaci\u00f3n de los \u00e1ngulos de torsi\u00f3n de distintas estructuras de hQC"},{"location":"ramachandran/#angulos-de-torsion-de-referencia","text":"En primer lugar, vamos a comparar los \u00e1ngulos de torsi\u00f3n calculados por nuestro programa con los valores de referencia que obtengamos por una aplicaci\u00f3n profesional. Por un lado, vamos a calcular los \u00e1ngulos de torsi\u00f3n para los residuos 34-40 de nuestra estructura 2AFM usando la aplicaci\u00f3n desarrollada. Y, por otro lado, vamos a emplear como referencia los \u00e1ngulos de torsi\u00f3n calculados por la aplicaci\u00f3n Torsion angles para la misma prote\u00edna. Como puede observarse en la Tabla 1, los valores son enormemente parecidos, diferenci\u00e1ndose \u00fanicamente debido a distintos criterios de redondeo. N\u00famero de residue Residuo \\(\\phi_{\\text{ref}}\\) \\(\\phi_{\\text{calculado}}\\) \\(\\psi_{\\text{ref}}\\) \\(\\psi_{\\text{calculado}}\\) 34 SER -41.80 -41.77 138.20 138.19 35 ALA -98.40 -98.42 22.50 22.48 36 TRP -59.90 -59.89 -31.10 -31.05 37 PRO -67.90 -67.86 -9.00 -9.03 38 GLU -89.60 -89.61 -10.40 -10.38 39 GLU -55.90 -55.90 -37.10 -37.10 40 LYS -56.70 -56.73 -28.00 -28.00 Tabla 1. Comparaci\u00f3n de los \u00e1ngulos de torsi\u00f3n calculados frente a un valor de referencia para la prote\u00edna 2AFM.","title":"\u00c1ngulos de torsi\u00f3n de referencia"},{"location":"ramachandran/#comparacion-diagrama-de-ramachandran","text":"En segundo lugar, vamos a comparar la estructura experimental 2AFW, que corresponde a la enzima hQC formando un complejo con N-acetilhistamina, uno de sus sustratos, con Q16769 de AlphaFold, que corresponde a la estructura nativa de la isoforma secretora. Para ello, hemos generado la siguiente representaci\u00f3n donde se muestran los residuos de 2AFW dibujados en azul y los de AlphaFold dibujados en blanco. En un principio, esperar\u00edamos que ambas estructuras fueran muy similares, pero se diferenciaran en unos pocos residuos: Aquellos residuos que forman la secuencia N-terminal de Q16769, responsable de su anclaje en el aparato de Golgi. Aquellos residuos que forman el sitio activo de la prote\u00edna y que est\u00e1 ligeramente m\u00e1s abierta en Q16769 que en 2AFW. Aquellos residuos de 2AFW que se hubieran visto afectados por la interacci\u00f3n de la enzima con su sustrato. Destacar que ser\u00eda interesante tambi\u00e9n comparar 2AFM (sin sustrato) con 2AFW (con sustrato) para poder \"aislar\" el efecto de la uni\u00f3n del sustrato a la enzima. Dicha imagen se puede observar en uno de los frames de la Figura 3, en la cual se puede ver c\u00f3mo ambos diagramas se superponen casi a la perfecci\u00f3n. Figura 4. Representaci\u00f3n esquem\u00e1tica del diagrama de Ramachandran para la prote\u00edna experimental 2AFM comparada con la prote\u00edna predecida por AlphaFold. En general, la agrupaci\u00f3n de los residuos dentro del diagrama concuerda con lo revisado en literatura a cerca de la estructura secundaria. Si comparamos la Figura 4 con la Figura 2, r\u00e1pidamente podemos ubicar los residuos que forman parte de hebras \\(\\beta\\) en la esquina superior izquierda, de h\u00e9lices \\(\\alpha\\) en el grupo de puntos debajo de este y en el lado derecho una nube de puntos que podr\u00eda corresponderse con h\u00e9lices con giro a la izquierda. Adem\u00e1s, la mayor parte de los puntos se encuentran en regiones no prohibidas est\u00e9ricamente, lo cual nos da una idea de la calidad de ambas estructuras.","title":"Comparaci\u00f3n diagrama de Ramachandran"},{"location":"ramachandran/#conclusion","text":"En conclusi\u00f3n, el programa y las funciones desarrolladas son capaces de, en primer lugar, calcular los \u00e1ngulos de torsi\u00f3n para una estructura de forma adecuada y muy precisa, al compararla con herramientas profesionales. Y , en segundo lugar, la interfaz y el m\u00f3dulo gr\u00e1fico nos permiten analizar dichos resultados para comparar estructuras y , por ejemplo, observar el efecto que tiene en la estructura la uni\u00f3n de una mol\u00e9cula de inter\u00e9s biol\u00f3gico (como un sustrato o un inhibidor, para estudiar la cat\u00e1lisis enzim\u00e1tica). Esta idea tambi\u00e9n ser\u00eda aplicable para comparar las diferencias estructurales entre una prote\u00edna nativa y con alguna mutaci\u00f3n.","title":"Conclusi\u00f3n"},{"location":"ramachandran/#referencias","text":"Golden, M., Garc\u00eda-Portugu\u00e9s, E., S\u00f8rensen, M., Mardia, K. V., Hamelryck, T., & Hein, J. (2017). A Generative Angular Model of Protein Structure Evolution. Molecular Biology and Evolution, 34(8), 2085-2100. https://doi.org/10.1093/molbev/msx137 . \u21a9 Imagen elaborada por Dcrjsr y obtenida a trav\u00e9s de Wikipedia. \u21a9","title":"Referencias"},{"location":"revision_bibliografica/","text":"Revisi\u00f3n bibliogr\u00e1fica \u00b6 A continuaci\u00f3n, desarrollamos una breve revisi\u00f3n bibliogr\u00e1fica sobre la prote\u00edna hQC, haciendo especial \u00e9nfasis en los aspectos estructurales y funcionales de la misma. Este apartado se corresponde a la 1\u00aa actividad de la relaci\u00f3n de ejercicios. Metodolog\u00eda \u00b6 En la realizaci\u00f3n de esta revisi\u00f3n bibliogr\u00e1fica se hizo uso de la base de datos Scopus para la selecci\u00f3n de un grupo reducido de revisiones y art\u00edculos de inter\u00e9s que trataran sobre esta prote\u00edna. Tambi\u00e9n se recurri\u00f3 la base de datos RCSB PDB para la b\u00fasqueda de estructuras experimentales disponibles para esta prote\u00ednas, cuyas caracter\u00edsticas principales se encuentran resumidas m\u00e1s adelante. Introducci\u00f3n \u00b6 La enzima hQC (Human glutaminyl cyclase), es una aminoaciltransferasa, EC 2.3.2, que se encuentra en plantas y animales. Esta enzima es objeto de numerosos estudios por su implicaci\u00f3n en patolog\u00edas como el Alzheimer, en cuya relaci\u00f3n nos centraremos en esta revisi\u00f3n (Gunn et al., 2021) 2 . Inter\u00e9s cl\u00ednico \u00b6 El Alzheimer es una enfermedad neurodegenerativa cr\u00f3nica y que afecta a poblaci\u00f3n envejecida causando demencia. Se estima que un 13% de la poblaci\u00f3n mayor a 65 a\u00f1os desarrolla Alzheimer y un 45% por enzima de los 85 a\u00f1os. Sin embargo, la tasa de fracaso de f\u00e1rmacos candidatos en ensayos cl\u00ednicos es una de las mayores en cualquier \u00e1rea de enfermedades, siendo superior al 99%. El Alzheimer es una enfermedad multifactorial sobre la cual se han propuesto diversas hip\u00f3tesis que explican los mecanismos por los que se origina (Vijayan & Zhang, 2019) 4 . Una de las hip\u00f3tesis con m\u00e1s aceptaci\u00f3n en la comunidad cient\u00edfica es la hip\u00f3tesis de la cascada amiloide. Seg\u00fan esta hip\u00f3tesis, es la deposici\u00f3n de la prote\u00edna \u03b2 amiloide, A\u03b2P, el agente causal de la enfermedad. Las placas que forman estos p\u00e9ptidos al depositarse est\u00e1n formadas por distintas especies de A\u03b2P. Una de ellas es el pGlu-A\u03b2 y su formaci\u00f3n est\u00e1 catalizada por la enzima QC, sobre la cual trata este trabajo y que est\u00e1 up-regulada durante el desarrollo de la enfermedad (Vijayan & Zhang, 2019) 4 . La enzima QC es capaz de catalizar la ciclaci\u00f3n del glutamato N-terminal a partir de su precursor glutaminilo. Esta reacci\u00f3n es una modificaci\u00f3n postraduccional de importancia en la maduraci\u00f3n de numerosos neurop\u00e9ptidos bioactivos, hormonas y citoquinas, durante su maduraci\u00f3n en la v\u00eda secretora (Gunn et al., 2021) 2 . M\u00e1s concretamente, en el caso del Alzheimer, la enzima QC cataliza la ciclaci\u00f3n del glutamano N-terminal en la posici\u00f3n 3 o 11 del A\u03b2P truncado. Esta modificaci\u00f3n, respecto al A\u03b2P sin modificar, aumenta la hidrofobicidad, la estabilidad, la propensi\u00f3n a agregarse y la neurotoxicidad. Actualmente, existen numerosos estudios que exploran posibilidad de utilizar inhibidores de de QC para reducir la producci\u00f3n de pGlu-A\u03b2 (Vijayan & Zhang, 2019) 4 . Adem\u00e1s del Alzheimer, se conoce la implicaci\u00f3n de esta enzima en las siguientes patolog\u00edas. La informaci\u00f3n mostrada a continuaci\u00f3n ha sido obtenida del trabajo de Coimbra & Salvador, 2021 1 . En procesos inflamatorios, debido a su intervenci\u00f3n en la maduraci\u00f3n de la citoquina CCL2. En c\u00e1ncer, debido a la modificaci\u00f3n del inmuno checkpoint CD47 y que es necesaria para una interacci\u00f3n efectiva de esta mol\u00e9cula con sus dianas. En periodontitis, enfermedad de las enc\u00edas, debido a que las principales bacterias causantes de esta enfermedad necesitan de la actividad de una QC bacteriana para el crecimiento y viabilidad celular. Adem\u00e1s, se ha relacionado una de estas bacterias, P. gingivalis el desarrollo de artritis reumatoide en pacientes. En este sentido, se conoce que la enzima QC se encuentra up-regulada en pacientes con esta patolog\u00eda. Inhibidores de hQC \u00b6 Los inhibidores de sQC basan su acci\u00f3n principalmente en la coordinaci\u00f3n entre un grupo de uni\u00f3n a metal con el i\u00f3n \\(Zn^{2+}\\) del sitio activo. Se distinguen los siguientes tipos de f\u00e1rmacos principalmente. La informaci\u00f3n mostrada a continuaci\u00f3n ha sido obtenida del trabajo de Vijayan & Zhang, 2019 4 . Inhibidores basados en imidazol. Inhibidores basados en benzimidazol. Inhibidores basados en metil triazol. Inhibidores basados en sulfol\u00edpidos extra\u00eddos de microalgas y y obtenidos mediante metabol\u00f3mica reversa. Aspectos estructurales de importancia \u00b6 Se conocen dos isoformas de la enzima QC en Homo sapiens , la llamada QC secretora, sQC, codificada por el gen QPCT localizado en el cromosoma 2p22.2, y la llamada QC golgi residente, gQC, codificada por el gen QPCTL, en el cromosoma 19q13.32 (Huang et al., 2005) 3 . La isoforma gQC se diferencia de la sQC en que tiene una secuencia N-terminal responsable de su anclaje en el aparato de Golgi (Vijayan & Zhang, 2019) 4 . Por lo dem\u00e1s, ambas isoformas son muy similares ( \\(C\\alpha RMSD < 1 \u00c5\\) ), por lo que podremos realizar consideraciones generales sobre las dos simult\u00e1neamente (Vijayan & Zhang, 2019) 4 . Poseen una estructura globular con un pliegue mixto \u03b1/\u03b2. La actividad glutaminil y glutamil ciclasa reside en el dominio maduro (residuos 33-361) de la prote\u00edna (Gunn et al., 2021) 2 Figura 1. Dominio maduro anotado con las estructuras secundarias de 2AFM. Elaboraci\u00f3n propia usando PyMOL. En el apartado de visualizaci\u00f3n se aborda en detalle la realizaci\u00f3n de estas im\u00e1genes. La estructura posee una topolog\u00eda de s\u00e1ndwich abierto con una l\u00e1mina \u03b2 central de seis hebras rodeada por \u03b1-h\u00e9lices a ambos lados. En un lado tenemos 2 \u03b1-h\u00e9lices, \u03b17 y \u03b19, y en el otro 6 que son \u03b12, \u03b13, \u03b14, \u03b15, \u03b16, y \u03b110. Esta l\u00e1mina \u03b2 central esta formada por dos hebras antiparalelas (\u03b21 y \u03b22) y 4 paralelas (\u03b23, \u03b24, \u03b25 y \u03b26) y constituye el coraz\u00f3n hidrof\u00f3bico de la mol\u00e9cula (Huang et al., 2005) 3 . Estructura del sitio activo \u00b6 El sitio activo est\u00e1 formado por 6 bucles entre \u03b13 y \u03b14, \u03b23 y \u03b15, \u03b24 y \u03b17, \u03b25 y \u03b18, \u03b18 y \u03b19, y \u03b26 y \u03b110. Consta de un i\u00f3n de Zinc situado en el bolsillo del sitio activo y que est\u00e1 coordinado tetra\u00e9dricamente con D159 O\u03b42, E202 O\u03b51, H330 N\u03b52 y una mol\u00e9cula de agua. Tambi\u00e9n resultan de inter\u00e9s una serie de residuos altamente conservados en el entorno del zinc a los que se les atribuye en literatura cierto papel en la cat\u00e1lisis. Estos residuos son E201, W207, D248, D305, F325 y W329 y se ha comprobado que mutaciones en estos amino\u00e1cidos reducen significativamente la actividad enzim\u00e1tica (Gunn et al., 2021) 2 . Ambas isoformas se diferencian en el tama\u00f1o del sitio activo debido a variaciones conformacionales en los lazos que forman parte del mismo. La isoforma gQC, Golgi residente, es ligeramente m\u00e1s ancha y m\u00e1s abierta que la sQC, secretora. (Vijayan & Zhang, 2019) 4 Estructuras experimentales disponibles \u00b6 En el momento en que se realiza esta revisi\u00f3n hay un total de 31 estructuras experimentales depositadas en el RCSB PDB. Muchas de ellas corresponden a prote\u00ednas mutantes o cristalizadas en presencia de su inhibidor, debido al inter\u00e9s cl\u00ednico de esta mol\u00e9cula. Para realizar este trabajo hemos escogido la prote\u00edna 2AFM, la cual posee una buena resoluci\u00f3n y corresponde a la prote\u00edna wild type . No obstante, en algunas actividades se ha decidido otras estructuras de esta prote\u00edna con el objetivo de realizar una comparaci\u00f3n o de comprobar si los programas utilizados funcionaban con otras estructuras de la misma prote\u00edna. Tabla 1. Resultados b\u00fasqueda en RCSB PDB. Elaboraci\u00f3n propia. PDB ID Resolution (\u00c5) R Free R Work Space Group Length a (\u00c5) Length b (\u00c5) Length c (\u00c5) Structure Title 2AFW 1.56 0.213 0.189 H 3 2 119.132 119.132 332.826 Crystal structure of human glutaminyl cyclase in complex with N-acetylhistamine 2AFX 1.64 0.205 0.177 H 3 2 119.013 119.013 332.821 Crystal structure of human glutaminyl cyclase in complex with 1-benzylimidazole 2AFM 1.66 0.204 0.182 H 3 2 119.029 19.029 332.938 Crystal structure of human glutaminyl cyclase at pH 6.5 2ZEO 1.66 0.194 0.175 H 3 2 119.226 119.226 332.457 Crystal structure of the human glutaminyl cyclase mutant D305E at 1.66 angstrom resolution 6YJY 1.67 0.1884 0.1694 H 3 2 119.274 119.274 334.459 Crystal structure of human glutaminyl cyclase in complex with neurotensin 1-5 2ZEF 1.67 0.208 0.185 H 3 2 119.161 119.161 333.064 Crystal structure of the human glutaminyl cyclase mutant E201D at 1.67 angstrom resolution 2AFZ 1.68 0.212 0.186 H 3 2 118.953 118.953 332.997 Crystal structure of human glutaminyl cyclase in complex with 1-vinylimidazole 7CP0 1.7 0.2228 0.2054 C 1 2 1 86.277 149.383 96.032 Crystal Structure of double mutant Y115E Y117E human Secretory Glutaminyl Cyclase 2ZED 1.7 0.213 0.18 H 3 2 118.926 118.926 332.499 Crystal structure of the human glutaminyl cyclase mutant S160A at 1.7 angstrom resolution 6GBX 1.72 0.18307 0.15819 C 1 2 1 86.14 149.81 95.98 Crystal structure of human glutaminyl cyclase variant Y115E-Y117E in complex with SEN177 2ZEN 1.78 0.205 0.178 H 3 2 119.237 119.237 332.405 Crystal structure of the human glutaminyl cyclase mutant D305A at 1.78 angstrom resolution 3SI2 1.8 0.2597 0.1844 P 21 21 21 41.76 83.06 95.71 Structure of glycosylated murine glutaminyl cyclase in presence of the inhibitor PQ50 (PDBD150) 2ZEH 1.8 0.207 0.181 H 3 2 119.051 119.051 332.652 Crystal structure of the human glutaminyl cyclase mutant E201Q at 1.8 angstrom resolution 7COZ 1.85 0.2362 0.1955 C 1 2 1 86.229 149.366 95.377 Crystal Structure of double mutant Y115E Y117E human Secretory Glutaminyl Cyclase in complex with LSB-41 6YI1 1.92 0.1862 0.1593 H 3 2 120.38 120.38 331.91 Crystal structure of human glutaminyl cyclase in complex with Glu(gamma-hydrazide)-Phe-Ala 3PBB 1.95 0.23892 0.18107 H 3 155.753 155.753 80.516 Crystal structure of human secretory glutaminyl cyclase in complex with PBD150 4YWY 1.95 0.21101 0.16408 C 1 2 1 86.429 149.54 96.21 Crystal Structure of double mutant Y115E Y117E human Glutaminyl Cyclase in complex with inhibitor PBD-150 3PBE 1.95 0.1904 0.14264 H 3 2 118.754 118.754 332.093 Crystal structure of the mutant W207F of human secretory glutaminyl cyclase 2ZEL 1.97 0.218 0.176 H 3 2 119.11 119.11 332.35 Crystal structure of the human glutaminyl cyclase mutant D248A at 1.97 angstrom resolution 2ZEE 1.99 0.219 0.176 H 3 2 119.12 119.12 332.006 Crystal structure of the human glutaminyl cyclase mutant S160G at 1.99 angstrom resolution 2ZEG 2.08 0.209 0.177 H 3 2 119.392 119.392 333.193 Crystal structure of the human glutaminyl cyclase mutant E201L at 2.08 angstrom resolution 4YU9 2.1 0.2542 0.21079 C 1 2 1 86.38 149.63 96.3 Crystal Structure of double mutant Y115E Y117E human Glutaminyl Cyclase 2ZEP 2.1 0.219 0.179 H 3 2 119.543 119.543 334.021 Crystal structure of the human glutaminyl cyclase mutant H319L at 2.1 angstrom resolution 3SI0 2.1 0.26358 0.20382 C 1 2 1 82.408 63.688 77.159 Structure of glycosylated human glutaminyl cyclase 2ZEM 2.18 0.223 0.179 H 3 2 118.778 118.778 332.5 Crystal structure of the human glutaminyl cyclase mutant D248Q at 2.18 angstrom resolution 2AFU 2.22 0.226 0.188 H 3 2 119.137 119.137 332.612 Crystal structure of human glutaminyl cyclase in complex with glutamine t-butyl ester 2AFS 2.22 0.222 0.189 H 3 2 119.447 119.447 333.848 Crystal structure of the genetic mutant R54W of human glutaminyl cyclase 2AFO 2.35 0.216 0.185 H 3 2 118.988 118.988 332.258 Crystal structure of human glutaminyl cyclase at pH 8.0 3SI1 2.9 0.3006 0.2451 P 21 21 21 43.24 86.87 97.16 Structure of glycosylated murine glutaminyl cyclase Mecanismo de acci\u00f3n de hQC \u00b6 Las QCs median la ciclaci\u00f3n de la glutamina o glutamato expuestos en el N-terminal con liberaci\u00f3n de agua o amoniaco. Para iniciar dicha ciclaci\u00f3n, el ion \\(Zn^{2+}\\) localizado en el sitio activo polariza el grupo \u03b3-amino del residuo y estabiliza el ani\u00f3n resultante del ataque nucleof\u00edlico sobre el carbono \u03b3-carbon\u00edlico. En este mecanismo intervienen tambi\u00e9n E201 y D248 apoyando la transferencia de protones y aportando estabilidad (Gunn et al., 2021) 2 . Figura 2. Mecanismo de acci\u00f3n de la enzima hQC. Obtenido de Huang et al., 2005 3 . A continuaci\u00f3n, se muestra un detalle del sitio de uni\u00f3n de la prote\u00edna. Se pueden observar los residuos que se destacan anteriormente. Para realizar esta imagen se han seleccionado los \u00e1tomos de hasta una distancia de 5 A del cofactor del sitio catal\u00edtico y se han realizado anotaciones sobre los carbonos alfa. Figura 3. Detalle del sitio de uni\u00f3n de la estructura 2AFM. Elaboraci\u00f3n propia. El c\u00f3digo en Python empleado para realizar la Figura 3 es el siguiente: set ray_opaque_background , off load data / processed / 2 AFM . pdb remove solvent select sitio_union , byres res 392 expand 5 remove ( not sitio_union ) hide cartoon show sticks zoom sitio_union label n . CA and sitio_union , \"( %s , %s )\" % ( resn , resi ) python import imageio cmd . ray ( 500 , 500 ) filename = \"sitio_union\" + \".png\" cmd . png ( filename ) python end Referencias \u00b6 Coimbra, J. R. M., & Salvador, J. A. R. (2021). A patent review of glutaminyl cyclase inhibitors (2004\u2013present). Expert Opinion on Therapeutic Patents, 31(9), 809-836. https://doi.org/10.1080/13543776.2021.1917549 \u21a9 Gunn, A. P., Wong, B. X., McLean, C., Fowler, C., Barnard, P. J., Duce, J. A., Roberts, B. R., & The AIBL Research Group. (2021). Increased glutaminyl cyclase activity in brains of Alzheimer\u2019s disease individuals. Journal of Neurochemistry, 156(6), 979-987. https://doi.org/10.1111/jnc.15114 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Huang, K.-F., Liu, Y.-L., Cheng, W.-J., Ko, T.-P., & Wang, A. H.-J. (2005). Crystal structures of human glutaminyl cyclase, an enzyme responsible for protein N-terminal pyroglutamate formation. Proceedings of the National Academy of Sciences, 102(37), 13117-13122. https://doi.org/10.1073/pnas.0504184102 \u21a9 \u21a9 \u21a9 Vijayan, D. K., & Zhang, K. Y. J. (2019). Human glutaminyl cyclase: Structure, function, inhibitors and involvement in Alzheimer\u2019s disease. Pharmacological Research, 147, 104342. https://doi.org/10.1016/j.phrs.2019.104342 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Revisi\u00f3n bibliogr\u00e1fica"},{"location":"revision_bibliografica/#revision-bibliografica","text":"A continuaci\u00f3n, desarrollamos una breve revisi\u00f3n bibliogr\u00e1fica sobre la prote\u00edna hQC, haciendo especial \u00e9nfasis en los aspectos estructurales y funcionales de la misma. Este apartado se corresponde a la 1\u00aa actividad de la relaci\u00f3n de ejercicios.","title":"Revisi\u00f3n bibliogr\u00e1fica"},{"location":"revision_bibliografica/#metodologia","text":"En la realizaci\u00f3n de esta revisi\u00f3n bibliogr\u00e1fica se hizo uso de la base de datos Scopus para la selecci\u00f3n de un grupo reducido de revisiones y art\u00edculos de inter\u00e9s que trataran sobre esta prote\u00edna. Tambi\u00e9n se recurri\u00f3 la base de datos RCSB PDB para la b\u00fasqueda de estructuras experimentales disponibles para esta prote\u00ednas, cuyas caracter\u00edsticas principales se encuentran resumidas m\u00e1s adelante.","title":"Metodolog\u00eda"},{"location":"revision_bibliografica/#introduccion","text":"La enzima hQC (Human glutaminyl cyclase), es una aminoaciltransferasa, EC 2.3.2, que se encuentra en plantas y animales. Esta enzima es objeto de numerosos estudios por su implicaci\u00f3n en patolog\u00edas como el Alzheimer, en cuya relaci\u00f3n nos centraremos en esta revisi\u00f3n (Gunn et al., 2021) 2 .","title":"Introducci\u00f3n"},{"location":"revision_bibliografica/#interes-clinico","text":"El Alzheimer es una enfermedad neurodegenerativa cr\u00f3nica y que afecta a poblaci\u00f3n envejecida causando demencia. Se estima que un 13% de la poblaci\u00f3n mayor a 65 a\u00f1os desarrolla Alzheimer y un 45% por enzima de los 85 a\u00f1os. Sin embargo, la tasa de fracaso de f\u00e1rmacos candidatos en ensayos cl\u00ednicos es una de las mayores en cualquier \u00e1rea de enfermedades, siendo superior al 99%. El Alzheimer es una enfermedad multifactorial sobre la cual se han propuesto diversas hip\u00f3tesis que explican los mecanismos por los que se origina (Vijayan & Zhang, 2019) 4 . Una de las hip\u00f3tesis con m\u00e1s aceptaci\u00f3n en la comunidad cient\u00edfica es la hip\u00f3tesis de la cascada amiloide. Seg\u00fan esta hip\u00f3tesis, es la deposici\u00f3n de la prote\u00edna \u03b2 amiloide, A\u03b2P, el agente causal de la enfermedad. Las placas que forman estos p\u00e9ptidos al depositarse est\u00e1n formadas por distintas especies de A\u03b2P. Una de ellas es el pGlu-A\u03b2 y su formaci\u00f3n est\u00e1 catalizada por la enzima QC, sobre la cual trata este trabajo y que est\u00e1 up-regulada durante el desarrollo de la enfermedad (Vijayan & Zhang, 2019) 4 . La enzima QC es capaz de catalizar la ciclaci\u00f3n del glutamato N-terminal a partir de su precursor glutaminilo. Esta reacci\u00f3n es una modificaci\u00f3n postraduccional de importancia en la maduraci\u00f3n de numerosos neurop\u00e9ptidos bioactivos, hormonas y citoquinas, durante su maduraci\u00f3n en la v\u00eda secretora (Gunn et al., 2021) 2 . M\u00e1s concretamente, en el caso del Alzheimer, la enzima QC cataliza la ciclaci\u00f3n del glutamano N-terminal en la posici\u00f3n 3 o 11 del A\u03b2P truncado. Esta modificaci\u00f3n, respecto al A\u03b2P sin modificar, aumenta la hidrofobicidad, la estabilidad, la propensi\u00f3n a agregarse y la neurotoxicidad. Actualmente, existen numerosos estudios que exploran posibilidad de utilizar inhibidores de de QC para reducir la producci\u00f3n de pGlu-A\u03b2 (Vijayan & Zhang, 2019) 4 . Adem\u00e1s del Alzheimer, se conoce la implicaci\u00f3n de esta enzima en las siguientes patolog\u00edas. La informaci\u00f3n mostrada a continuaci\u00f3n ha sido obtenida del trabajo de Coimbra & Salvador, 2021 1 . En procesos inflamatorios, debido a su intervenci\u00f3n en la maduraci\u00f3n de la citoquina CCL2. En c\u00e1ncer, debido a la modificaci\u00f3n del inmuno checkpoint CD47 y que es necesaria para una interacci\u00f3n efectiva de esta mol\u00e9cula con sus dianas. En periodontitis, enfermedad de las enc\u00edas, debido a que las principales bacterias causantes de esta enfermedad necesitan de la actividad de una QC bacteriana para el crecimiento y viabilidad celular. Adem\u00e1s, se ha relacionado una de estas bacterias, P. gingivalis el desarrollo de artritis reumatoide en pacientes. En este sentido, se conoce que la enzima QC se encuentra up-regulada en pacientes con esta patolog\u00eda.","title":"Inter\u00e9s cl\u00ednico"},{"location":"revision_bibliografica/#inhibidores-de-hqc","text":"Los inhibidores de sQC basan su acci\u00f3n principalmente en la coordinaci\u00f3n entre un grupo de uni\u00f3n a metal con el i\u00f3n \\(Zn^{2+}\\) del sitio activo. Se distinguen los siguientes tipos de f\u00e1rmacos principalmente. La informaci\u00f3n mostrada a continuaci\u00f3n ha sido obtenida del trabajo de Vijayan & Zhang, 2019 4 . Inhibidores basados en imidazol. Inhibidores basados en benzimidazol. Inhibidores basados en metil triazol. Inhibidores basados en sulfol\u00edpidos extra\u00eddos de microalgas y y obtenidos mediante metabol\u00f3mica reversa.","title":"Inhibidores de hQC"},{"location":"revision_bibliografica/#aspectos-estructurales-de-importancia","text":"Se conocen dos isoformas de la enzima QC en Homo sapiens , la llamada QC secretora, sQC, codificada por el gen QPCT localizado en el cromosoma 2p22.2, y la llamada QC golgi residente, gQC, codificada por el gen QPCTL, en el cromosoma 19q13.32 (Huang et al., 2005) 3 . La isoforma gQC se diferencia de la sQC en que tiene una secuencia N-terminal responsable de su anclaje en el aparato de Golgi (Vijayan & Zhang, 2019) 4 . Por lo dem\u00e1s, ambas isoformas son muy similares ( \\(C\\alpha RMSD < 1 \u00c5\\) ), por lo que podremos realizar consideraciones generales sobre las dos simult\u00e1neamente (Vijayan & Zhang, 2019) 4 . Poseen una estructura globular con un pliegue mixto \u03b1/\u03b2. La actividad glutaminil y glutamil ciclasa reside en el dominio maduro (residuos 33-361) de la prote\u00edna (Gunn et al., 2021) 2 Figura 1. Dominio maduro anotado con las estructuras secundarias de 2AFM. Elaboraci\u00f3n propia usando PyMOL. En el apartado de visualizaci\u00f3n se aborda en detalle la realizaci\u00f3n de estas im\u00e1genes. La estructura posee una topolog\u00eda de s\u00e1ndwich abierto con una l\u00e1mina \u03b2 central de seis hebras rodeada por \u03b1-h\u00e9lices a ambos lados. En un lado tenemos 2 \u03b1-h\u00e9lices, \u03b17 y \u03b19, y en el otro 6 que son \u03b12, \u03b13, \u03b14, \u03b15, \u03b16, y \u03b110. Esta l\u00e1mina \u03b2 central esta formada por dos hebras antiparalelas (\u03b21 y \u03b22) y 4 paralelas (\u03b23, \u03b24, \u03b25 y \u03b26) y constituye el coraz\u00f3n hidrof\u00f3bico de la mol\u00e9cula (Huang et al., 2005) 3 .","title":"Aspectos estructurales de importancia"},{"location":"revision_bibliografica/#estructura-del-sitio-activo","text":"El sitio activo est\u00e1 formado por 6 bucles entre \u03b13 y \u03b14, \u03b23 y \u03b15, \u03b24 y \u03b17, \u03b25 y \u03b18, \u03b18 y \u03b19, y \u03b26 y \u03b110. Consta de un i\u00f3n de Zinc situado en el bolsillo del sitio activo y que est\u00e1 coordinado tetra\u00e9dricamente con D159 O\u03b42, E202 O\u03b51, H330 N\u03b52 y una mol\u00e9cula de agua. Tambi\u00e9n resultan de inter\u00e9s una serie de residuos altamente conservados en el entorno del zinc a los que se les atribuye en literatura cierto papel en la cat\u00e1lisis. Estos residuos son E201, W207, D248, D305, F325 y W329 y se ha comprobado que mutaciones en estos amino\u00e1cidos reducen significativamente la actividad enzim\u00e1tica (Gunn et al., 2021) 2 . Ambas isoformas se diferencian en el tama\u00f1o del sitio activo debido a variaciones conformacionales en los lazos que forman parte del mismo. La isoforma gQC, Golgi residente, es ligeramente m\u00e1s ancha y m\u00e1s abierta que la sQC, secretora. (Vijayan & Zhang, 2019) 4","title":"Estructura del sitio activo"},{"location":"revision_bibliografica/#estructuras-experimentales-disponibles","text":"En el momento en que se realiza esta revisi\u00f3n hay un total de 31 estructuras experimentales depositadas en el RCSB PDB. Muchas de ellas corresponden a prote\u00ednas mutantes o cristalizadas en presencia de su inhibidor, debido al inter\u00e9s cl\u00ednico de esta mol\u00e9cula. Para realizar este trabajo hemos escogido la prote\u00edna 2AFM, la cual posee una buena resoluci\u00f3n y corresponde a la prote\u00edna wild type . No obstante, en algunas actividades se ha decidido otras estructuras de esta prote\u00edna con el objetivo de realizar una comparaci\u00f3n o de comprobar si los programas utilizados funcionaban con otras estructuras de la misma prote\u00edna. Tabla 1. Resultados b\u00fasqueda en RCSB PDB. Elaboraci\u00f3n propia. PDB ID Resolution (\u00c5) R Free R Work Space Group Length a (\u00c5) Length b (\u00c5) Length c (\u00c5) Structure Title 2AFW 1.56 0.213 0.189 H 3 2 119.132 119.132 332.826 Crystal structure of human glutaminyl cyclase in complex with N-acetylhistamine 2AFX 1.64 0.205 0.177 H 3 2 119.013 119.013 332.821 Crystal structure of human glutaminyl cyclase in complex with 1-benzylimidazole 2AFM 1.66 0.204 0.182 H 3 2 119.029 19.029 332.938 Crystal structure of human glutaminyl cyclase at pH 6.5 2ZEO 1.66 0.194 0.175 H 3 2 119.226 119.226 332.457 Crystal structure of the human glutaminyl cyclase mutant D305E at 1.66 angstrom resolution 6YJY 1.67 0.1884 0.1694 H 3 2 119.274 119.274 334.459 Crystal structure of human glutaminyl cyclase in complex with neurotensin 1-5 2ZEF 1.67 0.208 0.185 H 3 2 119.161 119.161 333.064 Crystal structure of the human glutaminyl cyclase mutant E201D at 1.67 angstrom resolution 2AFZ 1.68 0.212 0.186 H 3 2 118.953 118.953 332.997 Crystal structure of human glutaminyl cyclase in complex with 1-vinylimidazole 7CP0 1.7 0.2228 0.2054 C 1 2 1 86.277 149.383 96.032 Crystal Structure of double mutant Y115E Y117E human Secretory Glutaminyl Cyclase 2ZED 1.7 0.213 0.18 H 3 2 118.926 118.926 332.499 Crystal structure of the human glutaminyl cyclase mutant S160A at 1.7 angstrom resolution 6GBX 1.72 0.18307 0.15819 C 1 2 1 86.14 149.81 95.98 Crystal structure of human glutaminyl cyclase variant Y115E-Y117E in complex with SEN177 2ZEN 1.78 0.205 0.178 H 3 2 119.237 119.237 332.405 Crystal structure of the human glutaminyl cyclase mutant D305A at 1.78 angstrom resolution 3SI2 1.8 0.2597 0.1844 P 21 21 21 41.76 83.06 95.71 Structure of glycosylated murine glutaminyl cyclase in presence of the inhibitor PQ50 (PDBD150) 2ZEH 1.8 0.207 0.181 H 3 2 119.051 119.051 332.652 Crystal structure of the human glutaminyl cyclase mutant E201Q at 1.8 angstrom resolution 7COZ 1.85 0.2362 0.1955 C 1 2 1 86.229 149.366 95.377 Crystal Structure of double mutant Y115E Y117E human Secretory Glutaminyl Cyclase in complex with LSB-41 6YI1 1.92 0.1862 0.1593 H 3 2 120.38 120.38 331.91 Crystal structure of human glutaminyl cyclase in complex with Glu(gamma-hydrazide)-Phe-Ala 3PBB 1.95 0.23892 0.18107 H 3 155.753 155.753 80.516 Crystal structure of human secretory glutaminyl cyclase in complex with PBD150 4YWY 1.95 0.21101 0.16408 C 1 2 1 86.429 149.54 96.21 Crystal Structure of double mutant Y115E Y117E human Glutaminyl Cyclase in complex with inhibitor PBD-150 3PBE 1.95 0.1904 0.14264 H 3 2 118.754 118.754 332.093 Crystal structure of the mutant W207F of human secretory glutaminyl cyclase 2ZEL 1.97 0.218 0.176 H 3 2 119.11 119.11 332.35 Crystal structure of the human glutaminyl cyclase mutant D248A at 1.97 angstrom resolution 2ZEE 1.99 0.219 0.176 H 3 2 119.12 119.12 332.006 Crystal structure of the human glutaminyl cyclase mutant S160G at 1.99 angstrom resolution 2ZEG 2.08 0.209 0.177 H 3 2 119.392 119.392 333.193 Crystal structure of the human glutaminyl cyclase mutant E201L at 2.08 angstrom resolution 4YU9 2.1 0.2542 0.21079 C 1 2 1 86.38 149.63 96.3 Crystal Structure of double mutant Y115E Y117E human Glutaminyl Cyclase 2ZEP 2.1 0.219 0.179 H 3 2 119.543 119.543 334.021 Crystal structure of the human glutaminyl cyclase mutant H319L at 2.1 angstrom resolution 3SI0 2.1 0.26358 0.20382 C 1 2 1 82.408 63.688 77.159 Structure of glycosylated human glutaminyl cyclase 2ZEM 2.18 0.223 0.179 H 3 2 118.778 118.778 332.5 Crystal structure of the human glutaminyl cyclase mutant D248Q at 2.18 angstrom resolution 2AFU 2.22 0.226 0.188 H 3 2 119.137 119.137 332.612 Crystal structure of human glutaminyl cyclase in complex with glutamine t-butyl ester 2AFS 2.22 0.222 0.189 H 3 2 119.447 119.447 333.848 Crystal structure of the genetic mutant R54W of human glutaminyl cyclase 2AFO 2.35 0.216 0.185 H 3 2 118.988 118.988 332.258 Crystal structure of human glutaminyl cyclase at pH 8.0 3SI1 2.9 0.3006 0.2451 P 21 21 21 43.24 86.87 97.16 Structure of glycosylated murine glutaminyl cyclase","title":"Estructuras experimentales disponibles"},{"location":"revision_bibliografica/#mecanismo-de-accion-de-hqc","text":"Las QCs median la ciclaci\u00f3n de la glutamina o glutamato expuestos en el N-terminal con liberaci\u00f3n de agua o amoniaco. Para iniciar dicha ciclaci\u00f3n, el ion \\(Zn^{2+}\\) localizado en el sitio activo polariza el grupo \u03b3-amino del residuo y estabiliza el ani\u00f3n resultante del ataque nucleof\u00edlico sobre el carbono \u03b3-carbon\u00edlico. En este mecanismo intervienen tambi\u00e9n E201 y D248 apoyando la transferencia de protones y aportando estabilidad (Gunn et al., 2021) 2 . Figura 2. Mecanismo de acci\u00f3n de la enzima hQC. Obtenido de Huang et al., 2005 3 . A continuaci\u00f3n, se muestra un detalle del sitio de uni\u00f3n de la prote\u00edna. Se pueden observar los residuos que se destacan anteriormente. Para realizar esta imagen se han seleccionado los \u00e1tomos de hasta una distancia de 5 A del cofactor del sitio catal\u00edtico y se han realizado anotaciones sobre los carbonos alfa. Figura 3. Detalle del sitio de uni\u00f3n de la estructura 2AFM. Elaboraci\u00f3n propia. El c\u00f3digo en Python empleado para realizar la Figura 3 es el siguiente: set ray_opaque_background , off load data / processed / 2 AFM . pdb remove solvent select sitio_union , byres res 392 expand 5 remove ( not sitio_union ) hide cartoon show sticks zoom sitio_union label n . CA and sitio_union , \"( %s , %s )\" % ( resn , resi ) python import imageio cmd . ray ( 500 , 500 ) filename = \"sitio_union\" + \".png\" cmd . png ( filename ) python end","title":"Mecanismo de acci\u00f3n de hQC"},{"location":"revision_bibliografica/#referencias","text":"Coimbra, J. R. M., & Salvador, J. A. R. (2021). A patent review of glutaminyl cyclase inhibitors (2004\u2013present). Expert Opinion on Therapeutic Patents, 31(9), 809-836. https://doi.org/10.1080/13543776.2021.1917549 \u21a9 Gunn, A. P., Wong, B. X., McLean, C., Fowler, C., Barnard, P. J., Duce, J. A., Roberts, B. R., & The AIBL Research Group. (2021). Increased glutaminyl cyclase activity in brains of Alzheimer\u2019s disease individuals. Journal of Neurochemistry, 156(6), 979-987. https://doi.org/10.1111/jnc.15114 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Huang, K.-F., Liu, Y.-L., Cheng, W.-J., Ko, T.-P., & Wang, A. H.-J. (2005). Crystal structures of human glutaminyl cyclase, an enzyme responsible for protein N-terminal pyroglutamate formation. Proceedings of the National Academy of Sciences, 102(37), 13117-13122. https://doi.org/10.1073/pnas.0504184102 \u21a9 \u21a9 \u21a9 Vijayan, D. K., & Zhang, K. Y. J. (2019). Human glutaminyl cyclase: Structure, function, inhibitors and involvement in Alzheimer\u2019s disease. Pharmacological Research, 147, 104342. https://doi.org/10.1016/j.phrs.2019.104342 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Referencias"},{"location":"rmsd/","text":"RMSD \u00b6 En la elaboraci\u00f3n de este cuaderno de actividades se pide el desarrollo de una aplicaci\u00f3n capaz En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una aplicaci\u00f3n capaz de calcular el RMSD o desviaci\u00f3n cuadr\u00e1tica media de una serie de residuos determinados por el usuario. El c\u00f3digo correspondiente a las funciones utilizadas se encuentran en la librer\u00eda biotools/src_biotools y la aplicaci\u00f3n bajo el nombre de RMSD . Este apartado se corresponde a la 9\u00aa actividad de la relaci\u00f3n de ejercicios. Calcular RMSD \u00b6 A continuaci\u00f3n, mostramos la definici\u00f3n de RMSD. \\[ RMSD = \\sqrt{\\frac{\\sum^{n}_{i, j}(Dist1_{i,j}-Dist2_{i,j})^2}{n}} \\] Antes de desarrollar una funci\u00f3n capaz de calcular el RMSD para una serie de puntos necesitaremos definir una serie de funciones que nos har\u00e1n falta. En primer lugar, definiremos una funci\u00f3n que calcule la distancia entre dos puntos en el espacio. Distancia (coordenadas) Distancia (TPunto) 1 2 3 4 function distancia3D ( a1 , b1 , c1 , a2 , b2 , c2 : real ) : real ; begin result := sqrt ( sqr ( a1 - a2 ) + sqr ( b1 - b2 ) + sqr ( c1 - c2 )) ; end ; 1 2 3 4 function distancia3D ( p1 , p2 : Tpunto ) : real ; overload ; begin result := sqrt ( sqr ( p1 . X - p2 . X ) + sqr ( p1 . Y - p2 . Y ) + sqr ( p1 . Z - p1 . Z )) ; end ; El siguiente paso consiste en crear una funci\u00f3n capaz de generar una matriz con las distancias internas entre todos los \u00e1tomos de un residuo. Una de las mejoras que se han implementado es que, aunque el ejercicio ped\u00eda inicialmente una funci\u00f3n capaz de calcular el RMSD entre distintas serinas, hemos querido generalizar un poco m\u00e1s, obteniendo una funci\u00f3n que calcula la matriz de distancias entre un conjunto de \u00e1tomos cual sea, independientemente del n\u00famero de puntos. De esta forma, dado un conjunto de \\(n\\) puntos en el espacio, esta funci\u00f3n devuelve una matriz de dimensiones \\(n\\times n\\) . Esta matriz contiene en la posici\u00f3n \\(M_{i, j}\\) la distancia entre los puntos \\(p_i\\) y \\(p_j\\) . Destacar que, al ser una matriz de distancias, la diagonal de la matriz debe estar compuesta \u00fanicamente por ceros. matriz_distancias() 1 2 3 4 5 6 7 8 9 10 11 function matriz_distancias ( puntos : TPuntos ) : ; var matriz : MatrizDistancias ; i , j , n : integer ; begin n := high ( puntos ) + 1 , SetLength ( matriz , n , n ) ; for i := 0 to n do for j := 0 to n do matriz [ i , j ] := distancia3D ( puntos [ i ] , puntos [ j ]) ; end ; A continuaci\u00f3n, se desarroll\u00f3 una funci\u00f3n que recibiera como argumento dos matrices de distancias y que fuese capaz de calcular el RMSD entre los dos conjuntos de puntos a los que pertenecen dichas matrices de distancia. RMSD_distan() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function RMSD_distan ( dist1 , dist2 : Matriz2D ) : real ; var sumatorio : real ; i , j , n : integer ; begin sumatorio := 0 ; n := high ( dist1 ) ; for i := 0 to n do begin for j := 0 to n do begin sumatorio := sumatorio + sqr ( dist1 [ i , j ] - dist2 [ i , j ]) ; end ; end ; result := sqrt ( sumatorio / n ) ; end ; Aplicaci\u00f3n Free Pascal/Lazarus \u00b6 Por \u00faltimo, se muestra la implementaci\u00f3n de las funciones anteriores en una aplicaci\u00f3n Free Pascal/Lazarus. Esta aplicaci\u00f3n tiene una interfaz gr\u00e1fica que permite al usuario elegir el tipo y n\u00famero de residuos a estudiar. Una posible mejora de este programa ser\u00eda una lograr una interfaz m\u00e1s sofisticada para que el usuario elija los residuos en que est\u00e1 interesado. El procedimiento principal de dicha aplicaci\u00f3n es complejo y se muestra a continuaci\u00f3n porque nos resulta interesante como, a partir de las funciones anteriores, se construye una matriz bidimensional con los resultados y se imprimen por pantalla en un formato adecuado. Dicha matriz es una matriz \\(r \\times r\\) , donde \\(r\\) es el n\u00famero de residuos a comparar y donde \\(M_{i,j, \\text{result}} = RMSD(r_i, r_j)\\) . Demostraci\u00f3n de uso \u00b6 Mostramos a continuaci\u00f3n una animaci\u00f3n mostrando el funcionamiento de la aplicaci\u00f3n. Destacar que funciona con distintos tipos de residuos (es decir, es capaz de dimensionar adecuadamente las matrices de distancias) y con distinto n\u00famero de residuos (es decir, tambi\u00e9n es capaz de dimensionar adecuadamente la matriz de resultados que contiene los valores de RMSD para distintos pares de residuos). Figura 1. Animaci\u00f3n del programa RMSD mostrando su uso. An\u00e1lisis serinas de hQC \u00b6 A continuaci\u00f3n, mostramos los resultados de nuestro programa al calcular los valores de RMSD por pares para las 4 primeras serinas de la prote\u00edna, que son los residuos 34, 50, 61 y 63. \\[ \\text{Pairwise RMSD} = \\begin{pmatrix}0.000 & 1.859 & 0.983 & 1.312\\\\ 1.859 & 0.000 & 1.708 & 1.682\\\\ 0.983 & 1.708 & 0.000 & 1.001\\\\ 1.312 & 1.682 & 1.001 & 0.000\\end{pmatrix} \\] Como se puede observar, el segundo residuo de serina, S50, es el m\u00e1s distinto al resto, teniendo los valores m\u00e1s elevados de RMSD. El tercer y cuarto residuo,S62 y S63, tienen valores bajos de RMSD, lo cual podr\u00eda explicarse con el hecho de que, al estar tan cerca, probablemente tengan entornos qu\u00edmicos muy parecidos. Sin embargo, el par de residuos m\u00e1s similar es el primero, S34 y el tercero, S50. A continuaci\u00f3n, se muestran en los 4 residuos anteriores anotados sobre la estructura de la prote\u00edna. Figura 2. Representaci\u00f3n cartoon de la estructura de 2AFM obtenida con PyMol. Los residuos han sido anotados con su c\u00f3digo de tres letras, su n\u00famero de residuo y con el factor B. Como conclusi\u00f3n, comentar que la informaci\u00f3n aportada por el RMSD es de gran inter\u00e9s puesto que nos permite determinar qu\u00e9 residuos podr\u00edan estar en entornos qu\u00edmicos m\u00e1s parecidos de forma num\u00e9rica.","title":"RMSD"},{"location":"rmsd/#rmsd","text":"En la elaboraci\u00f3n de este cuaderno de actividades se pide el desarrollo de una aplicaci\u00f3n capaz En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una aplicaci\u00f3n capaz de calcular el RMSD o desviaci\u00f3n cuadr\u00e1tica media de una serie de residuos determinados por el usuario. El c\u00f3digo correspondiente a las funciones utilizadas se encuentran en la librer\u00eda biotools/src_biotools y la aplicaci\u00f3n bajo el nombre de RMSD . Este apartado se corresponde a la 9\u00aa actividad de la relaci\u00f3n de ejercicios.","title":"RMSD"},{"location":"rmsd/#calcular-rmsd","text":"A continuaci\u00f3n, mostramos la definici\u00f3n de RMSD. \\[ RMSD = \\sqrt{\\frac{\\sum^{n}_{i, j}(Dist1_{i,j}-Dist2_{i,j})^2}{n}} \\] Antes de desarrollar una funci\u00f3n capaz de calcular el RMSD para una serie de puntos necesitaremos definir una serie de funciones que nos har\u00e1n falta. En primer lugar, definiremos una funci\u00f3n que calcule la distancia entre dos puntos en el espacio. Distancia (coordenadas) Distancia (TPunto) 1 2 3 4 function distancia3D ( a1 , b1 , c1 , a2 , b2 , c2 : real ) : real ; begin result := sqrt ( sqr ( a1 - a2 ) + sqr ( b1 - b2 ) + sqr ( c1 - c2 )) ; end ; 1 2 3 4 function distancia3D ( p1 , p2 : Tpunto ) : real ; overload ; begin result := sqrt ( sqr ( p1 . X - p2 . X ) + sqr ( p1 . Y - p2 . Y ) + sqr ( p1 . Z - p1 . Z )) ; end ; El siguiente paso consiste en crear una funci\u00f3n capaz de generar una matriz con las distancias internas entre todos los \u00e1tomos de un residuo. Una de las mejoras que se han implementado es que, aunque el ejercicio ped\u00eda inicialmente una funci\u00f3n capaz de calcular el RMSD entre distintas serinas, hemos querido generalizar un poco m\u00e1s, obteniendo una funci\u00f3n que calcula la matriz de distancias entre un conjunto de \u00e1tomos cual sea, independientemente del n\u00famero de puntos. De esta forma, dado un conjunto de \\(n\\) puntos en el espacio, esta funci\u00f3n devuelve una matriz de dimensiones \\(n\\times n\\) . Esta matriz contiene en la posici\u00f3n \\(M_{i, j}\\) la distancia entre los puntos \\(p_i\\) y \\(p_j\\) . Destacar que, al ser una matriz de distancias, la diagonal de la matriz debe estar compuesta \u00fanicamente por ceros. matriz_distancias() 1 2 3 4 5 6 7 8 9 10 11 function matriz_distancias ( puntos : TPuntos ) : ; var matriz : MatrizDistancias ; i , j , n : integer ; begin n := high ( puntos ) + 1 , SetLength ( matriz , n , n ) ; for i := 0 to n do for j := 0 to n do matriz [ i , j ] := distancia3D ( puntos [ i ] , puntos [ j ]) ; end ; A continuaci\u00f3n, se desarroll\u00f3 una funci\u00f3n que recibiera como argumento dos matrices de distancias y que fuese capaz de calcular el RMSD entre los dos conjuntos de puntos a los que pertenecen dichas matrices de distancia. RMSD_distan() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function RMSD_distan ( dist1 , dist2 : Matriz2D ) : real ; var sumatorio : real ; i , j , n : integer ; begin sumatorio := 0 ; n := high ( dist1 ) ; for i := 0 to n do begin for j := 0 to n do begin sumatorio := sumatorio + sqr ( dist1 [ i , j ] - dist2 [ i , j ]) ; end ; end ; result := sqrt ( sumatorio / n ) ; end ;","title":"Calcular RMSD"},{"location":"rmsd/#aplicacion-free-pascallazarus","text":"Por \u00faltimo, se muestra la implementaci\u00f3n de las funciones anteriores en una aplicaci\u00f3n Free Pascal/Lazarus. Esta aplicaci\u00f3n tiene una interfaz gr\u00e1fica que permite al usuario elegir el tipo y n\u00famero de residuos a estudiar. Una posible mejora de este programa ser\u00eda una lograr una interfaz m\u00e1s sofisticada para que el usuario elija los residuos en que est\u00e1 interesado. El procedimiento principal de dicha aplicaci\u00f3n es complejo y se muestra a continuaci\u00f3n porque nos resulta interesante como, a partir de las funciones anteriores, se construye una matriz bidimensional con los resultados y se imprimen por pantalla en un formato adecuado. Dicha matriz es una matriz \\(r \\times r\\) , donde \\(r\\) es el n\u00famero de residuos a comparar y donde \\(M_{i,j, \\text{result}} = RMSD(r_i, r_j)\\) .","title":"Aplicaci\u00f3n Free Pascal/Lazarus"},{"location":"rmsd/#demostracion-de-uso","text":"Mostramos a continuaci\u00f3n una animaci\u00f3n mostrando el funcionamiento de la aplicaci\u00f3n. Destacar que funciona con distintos tipos de residuos (es decir, es capaz de dimensionar adecuadamente las matrices de distancias) y con distinto n\u00famero de residuos (es decir, tambi\u00e9n es capaz de dimensionar adecuadamente la matriz de resultados que contiene los valores de RMSD para distintos pares de residuos). Figura 1. Animaci\u00f3n del programa RMSD mostrando su uso.","title":"Demostraci\u00f3n de uso"},{"location":"rmsd/#analisis-serinas-de-hqc","text":"A continuaci\u00f3n, mostramos los resultados de nuestro programa al calcular los valores de RMSD por pares para las 4 primeras serinas de la prote\u00edna, que son los residuos 34, 50, 61 y 63. \\[ \\text{Pairwise RMSD} = \\begin{pmatrix}0.000 & 1.859 & 0.983 & 1.312\\\\ 1.859 & 0.000 & 1.708 & 1.682\\\\ 0.983 & 1.708 & 0.000 & 1.001\\\\ 1.312 & 1.682 & 1.001 & 0.000\\end{pmatrix} \\] Como se puede observar, el segundo residuo de serina, S50, es el m\u00e1s distinto al resto, teniendo los valores m\u00e1s elevados de RMSD. El tercer y cuarto residuo,S62 y S63, tienen valores bajos de RMSD, lo cual podr\u00eda explicarse con el hecho de que, al estar tan cerca, probablemente tengan entornos qu\u00edmicos muy parecidos. Sin embargo, el par de residuos m\u00e1s similar es el primero, S34 y el tercero, S50. A continuaci\u00f3n, se muestran en los 4 residuos anteriores anotados sobre la estructura de la prote\u00edna. Figura 2. Representaci\u00f3n cartoon de la estructura de 2AFM obtenida con PyMol. Los residuos han sido anotados con su c\u00f3digo de tres letras, su n\u00famero de residuo y con el factor B. Como conclusi\u00f3n, comentar que la informaci\u00f3n aportada por el RMSD es de gran inter\u00e9s puesto que nos permite determinar qu\u00e9 residuos podr\u00edan estar en entornos qu\u00edmicos m\u00e1s parecidos de forma num\u00e9rica.","title":"An\u00e1lisis serinas de hQC"},{"location":"simulacion_MD/","text":"Simulaci\u00f3n de din\u00e1mica molecular (extra) \u00b6 Las simulaciones de din\u00e1mica molecular (MD) predicen c\u00f3mo se mueven cada \u00e1tomo de una prote\u00edna a lo largo del tiempo en base a un modelo f\u00edsico que estipula c\u00f3mo son las interacciones interat\u00f3micas. Estas simulaciones se basan en la idea de que, dadas las posiciones de todos los \u00e1tomos de un sistema (una prote\u00edna rodeada por agua, por ejemplo), es posible calcular la fuerza que es ejercida sobre cada \u00e1tomo por el resto (a partir de un modelo complejo que se conoce como molecular mechanics force field ) y, usando las leyes de Newton, predecir la posici\u00f3n espacial de cada \u00e1tomo en funci\u00f3n del tiempo. El resultado de una simulaci\u00f3n MD es una trayectoria que describe el movimiento de los \u00e1tomos durante un intervalo (Hollingsworth & Dror, 2018) 3 . Como parte de la exploraci\u00f3n de la prote\u00edna human glutaminyl cyclase, se realiz\u00f3 una simulaci\u00f3n de MD utilizando el cuaderno alojado en Google Colab y propuesto en el art\u00edcuo Making it Rain: Cloud-Based Molecular Simulations for Everyone (Arantes et al., 2021) 1 . Antes de llevar a cabo la simulaci\u00f3n se realizaron los siguientes preparativos. : Se descarg\u00f3 la estructura 2AFM del RCSB PDB . Se gener\u00f3 un archivo de topolog\u00eda empleando el software AMBER (esto es, un archivo que describe los tipos de \u00e1tomos, las conectividades y otros par\u00e1metros necesarios para el force field ). Se a\u00f1adieron mol\u00e9culas de agua al modelo molecular creado a partir del PDB que solvataran la prote\u00edna y se neutraliz\u00f3 el sistema a\u00f1adiendo iones. Una vez se hab\u00edan generado los dos ficheros que describ\u00edan el sistema (el archivo de coordenadas y el de topolog\u00eda), se llev\u00f3 a cabo una etapa de equilibraci\u00f3n. Esto es el proceso por el cual se calcula y se descarta el segmento inicial de la simulaci\u00f3n hasta que se alcance un estado estacionario, puesto que los primeros cientos de picosegundos no suelen aportar informaci\u00f3n relevante. Esta simulaci\u00f3n ha sido realizada con objetivos educativos pero, realizada de una forma m\u00e1s rigurosa y empleando mayor poder computacional, podr\u00eda utilizarse para estudiar la estabilidad y flexibilidad conformacional de la estructura 2AFM. Podr\u00eda usarse, por ejemplo, para el refinamiento del modelo estructural o la identificaci\u00f3n de lazos muy flexibles o poco estables. A continuaci\u00f3n se muestran los resultados de la misma. Representaci\u00f3n gr\u00e1fica de la trayectoria utilizando py3Dmol An\u00e1lisis de la trayectoria usando bio3d \u00b6 A continuaci\u00f3n, mostramos el an\u00e1lisis que se hizo de la trayectoria resultante de la simulaci\u00f3n. Para ello se emple\u00f3 la librer\u00eda de R bio3d (Grant et al., 2006) 2 . En primer lugar, se seleccionaron los Carbonos \\(\\aplha\\) y se superpusieron cada uno de los frames que componen la trayectoria. A partir de esto podr\u00edamos obtener la estructura promedio de nuestro prote\u00edna pero, puesto que no se extendi\u00f3 la simulaci\u00f3n por cuestiones de tiempo, no tendr\u00eda mucho sentido. RMSD \u00b6 A continuaci\u00f3n, mostramos c\u00f3mo evoluciona el RMSD ( root-mean-square deviation of atomic positions ) con el tiempo y un histograma para observar la distribuci\u00f3n de los valores de RMSD. Como podemos observar, la tendencia del RMSD es a aumentar, lo que nos indica que la estructura no se habr\u00eda llegado a estabilizar y que ser\u00eda necesario ampliar la extensi\u00f3n de la simulaci\u00f3n. No obstante, si esa tendencia se mantuviera y llegase a estabilizarse podr\u00eda significar que la prote\u00edna sufre una \"relajaci\u00f3n\" en su estructura debido, por ejemplo, a que la estructura en condiciones fisiol\u00f3gicas es ligeramente diferente a la estructura cristalina. RMSF \u00b6 Despu\u00e9s, calculamos el RMSF ( Root mean square fluctuation ) para cada residuo. El RMSF es utilizado como una medida de la varianza conformacional de la estructura y nos indica las regiones de alta y baja movilidad. A continuaci\u00f3n, mostramos el RMSF para cada residuo. Destacamos que los residuos E201, W207, D248, D305, F325 y W329, que en bibliograf\u00eda se expuso que eran residuos conservados e implicados en la actividad enzim\u00e1tica, se localizan en m\u00ednimos locales de la gr\u00e1fica anterior, lo cual nos indican que tienen una baja movilidad. An\u00e1lisis de componente principal \u00b6 El an\u00e1lisis de componente principal (PCA) puede utilizarse para estudiar las relaciones entre todas las conformaciones por las que pasa nuestra estructura en la simulaci\u00f3n. Este m\u00e9todo nos proporciona una serie de componentes principales (eigenvectores) que describen los ejes de m\u00e1xima varianza en la distribuci\u00f3n de las conformaciones. Esta t\u00e9cnica permite reducir la dimensionalidad de los datos (proyecto la distribuci\u00f3n original en el subespacio definido por los componentes principales que se consideren). De hecho, en simulaciones de este tipo realizadas de forma rigurosa se observa que con 3-5 dimensiones se puede capturar al menos el 70% de la varianza total de las fluctuaciones posicionales de los \u00e1tomos resultante de una simulaci\u00f3n de din\u00e1mica molecular (Grant et al., 2006) 2 . En nuestro caso, como se puede observar en la imagen de la esquina inferior derecha de la siguiente figura, son necesarias las 8 primeras componentes, aunque la mayor parte de la varianza queda recogida en las 3 primeras. En la siguiente imagen se muestran la distribuci\u00f3n de cada frame proyectadas en el subespacio definido por las 3 primeras componentes y coloreadas seg\u00fan el momento en el tiempo que les corresponde en la simulaci\u00f3n (de azul a rojo). Como se puede observar en la imagen anterior, se puede observar la evoluci\u00f3n progresiva de las conformaciones en la simulaci\u00f3n. En el eje de PC1 se puede observar como los valores en la proyecci\u00f3n tienden a aumentar con el tiempo y, como consecuencia, los frames iniciales y finales en la simulaci\u00f3n se separan notablemente. No sucede as\u00ed en el eje de PC2, donde los valores que toman los frames iniciales y finales son muy parecidos (podr\u00edamos interpretarlo de manera intuitiva como si la estructura \"volviese\" a la disposici\u00f3n inicial. Por \u00faltimo, en el eje PC3 observamos como los valores oscilan entre unos valores m\u00e1ximos y m\u00ednimos. Ser\u00eda muy interesante extender la simulaci\u00f3n de din\u00e1mica molecular en el tiempo para poder observar si dicho patr\u00f3n se mantiene. A continuaci\u00f3n, y para explorar m\u00e1s posibilidades en el an\u00e1lisis, realizamos un clustering en el espacio definido por las PC. Los resultados nos muestran dos grupos que corresponden a la evoluci\u00f3n temporal de la simulaci\u00f3n (es decir, conformaciones iniciales y finales), lo cual nos indica que el sistema estar\u00eda evolucionando de manera lineal y no peri\u00f3dica (alternando entre conformaciones, por ejemplo). El siguiente paso que damos, es preguntarnos por la contribuci\u00f3n de cada residuo a la varianza explicada por los dos primeros PC, lo cual se refleja en la siguiente figura (la l\u00ednea en negro corresponde a la PC1 y en azul a la PC2). Estos dos componentes, con una varianza acumulada del 50%, son explicados de manera bastante homog\u00e9nea por todos los residuos, aunque los picos en 240 y 295 nos pueden indicar que los residuos de dicha zona estar\u00edan alterando su conformaci\u00f3n de manera significativa. An\u00e1lisis de correlaci\u00f3n cruzada \u00b6 Otro aspecto muy relevante en el an\u00e1lisis de las simulaciones de din\u00e1mica molecular es el estudio de c\u00f3mo las fluctuaciones o desplazamiento de un \u00e1tomo puede estar correlacionado con la fluctuaci\u00f3n de otro. De nuevo, para poder resultados fiables, ser\u00eda necesario disponer de una simulaci\u00f3n de ma\u015b duraci\u00f3n y realizada de manera m\u00e1s rigurosa aunque, con fines educativos, procederemos a estudiar las posibles correlaciones. Para ello, se construye una matriz compuesta por todos los coeficientes de correlaci\u00f3p cruzada por pares. Esta matriz se visualiza en la siguiente figura con una representaci\u00f3n gr\u00e1fica denominado DCCM ( dynamical cross-correlation map ). En concreto, nos interesan aquellas correlaciones entre residuos alejados en la secuencia de la prote\u00edna y que puedan deberse, por ejemplo, a interacciones en la estructura terciaria. Como puede observarse en la imagen anterior, se observan demasiadas se\u00f1ales entre todos los residuos, lo cual nos puede indicar que en la simulaci\u00f3n no se lleg\u00f3 a equilibrar el sistema y ser\u00eda necesario extender la simulaci\u00f3n en el tiempo. Estas correlaciones las podemos visualizar directamente sobre la estructura de la prote\u00edna utilizando el software pyMol. En la siguiente imagen se muestran algunas de las correlaciones en forma de l\u00edneas rojas y en forma de l\u00edneas azules las anticorrelaciones. Referencias \u00b6 Arantes, P. R., Pol\u00eato, M. D., Pedebos, C., & Ligabue-Braun, R. (2021). Making it Rain: Cloud-Based Molecular Simulations for Everyone. Journal of Chemical Information and Modeling, 61(10), 4852-4856. https://doi.org/10.1021/acs.jcim.1c00998 \u21a9 Grant, B. J., Rodrigues, A. P. C., ElSawy, K. M., McCammon, J. A., & Caves, L. S. D. (2006). Bio3d: An R package for the comparative analysis of protein structures. Bioinformatics, 22(21), 2695-2696. https://doi.org/10.1093/bioinformatics/btl461 \u21a9 \u21a9 Hollingsworth, S. A., & Dror, R. O. (2018). Molecular Dynamics Simulation for All. Neuron, 99(6), 1129-1143. https://doi.org/10.1016/j.neuron.2018.08.011 \u21a9","title":"Simulaci\u00f3n de din\u00e1mica molecular (extra)"},{"location":"simulacion_MD/#simulacion-de-dinamica-molecular-extra","text":"Las simulaciones de din\u00e1mica molecular (MD) predicen c\u00f3mo se mueven cada \u00e1tomo de una prote\u00edna a lo largo del tiempo en base a un modelo f\u00edsico que estipula c\u00f3mo son las interacciones interat\u00f3micas. Estas simulaciones se basan en la idea de que, dadas las posiciones de todos los \u00e1tomos de un sistema (una prote\u00edna rodeada por agua, por ejemplo), es posible calcular la fuerza que es ejercida sobre cada \u00e1tomo por el resto (a partir de un modelo complejo que se conoce como molecular mechanics force field ) y, usando las leyes de Newton, predecir la posici\u00f3n espacial de cada \u00e1tomo en funci\u00f3n del tiempo. El resultado de una simulaci\u00f3n MD es una trayectoria que describe el movimiento de los \u00e1tomos durante un intervalo (Hollingsworth & Dror, 2018) 3 . Como parte de la exploraci\u00f3n de la prote\u00edna human glutaminyl cyclase, se realiz\u00f3 una simulaci\u00f3n de MD utilizando el cuaderno alojado en Google Colab y propuesto en el art\u00edcuo Making it Rain: Cloud-Based Molecular Simulations for Everyone (Arantes et al., 2021) 1 . Antes de llevar a cabo la simulaci\u00f3n se realizaron los siguientes preparativos. : Se descarg\u00f3 la estructura 2AFM del RCSB PDB . Se gener\u00f3 un archivo de topolog\u00eda empleando el software AMBER (esto es, un archivo que describe los tipos de \u00e1tomos, las conectividades y otros par\u00e1metros necesarios para el force field ). Se a\u00f1adieron mol\u00e9culas de agua al modelo molecular creado a partir del PDB que solvataran la prote\u00edna y se neutraliz\u00f3 el sistema a\u00f1adiendo iones. Una vez se hab\u00edan generado los dos ficheros que describ\u00edan el sistema (el archivo de coordenadas y el de topolog\u00eda), se llev\u00f3 a cabo una etapa de equilibraci\u00f3n. Esto es el proceso por el cual se calcula y se descarta el segmento inicial de la simulaci\u00f3n hasta que se alcance un estado estacionario, puesto que los primeros cientos de picosegundos no suelen aportar informaci\u00f3n relevante. Esta simulaci\u00f3n ha sido realizada con objetivos educativos pero, realizada de una forma m\u00e1s rigurosa y empleando mayor poder computacional, podr\u00eda utilizarse para estudiar la estabilidad y flexibilidad conformacional de la estructura 2AFM. Podr\u00eda usarse, por ejemplo, para el refinamiento del modelo estructural o la identificaci\u00f3n de lazos muy flexibles o poco estables. A continuaci\u00f3n se muestran los resultados de la misma. Representaci\u00f3n gr\u00e1fica de la trayectoria utilizando py3Dmol","title":"Simulaci\u00f3n de din\u00e1mica molecular (extra)"},{"location":"simulacion_MD/#analisis-de-la-trayectoria-usando-bio3d","text":"A continuaci\u00f3n, mostramos el an\u00e1lisis que se hizo de la trayectoria resultante de la simulaci\u00f3n. Para ello se emple\u00f3 la librer\u00eda de R bio3d (Grant et al., 2006) 2 . En primer lugar, se seleccionaron los Carbonos \\(\\aplha\\) y se superpusieron cada uno de los frames que componen la trayectoria. A partir de esto podr\u00edamos obtener la estructura promedio de nuestro prote\u00edna pero, puesto que no se extendi\u00f3 la simulaci\u00f3n por cuestiones de tiempo, no tendr\u00eda mucho sentido.","title":"An\u00e1lisis de la trayectoria usando bio3d"},{"location":"simulacion_MD/#rmsd","text":"A continuaci\u00f3n, mostramos c\u00f3mo evoluciona el RMSD ( root-mean-square deviation of atomic positions ) con el tiempo y un histograma para observar la distribuci\u00f3n de los valores de RMSD. Como podemos observar, la tendencia del RMSD es a aumentar, lo que nos indica que la estructura no se habr\u00eda llegado a estabilizar y que ser\u00eda necesario ampliar la extensi\u00f3n de la simulaci\u00f3n. No obstante, si esa tendencia se mantuviera y llegase a estabilizarse podr\u00eda significar que la prote\u00edna sufre una \"relajaci\u00f3n\" en su estructura debido, por ejemplo, a que la estructura en condiciones fisiol\u00f3gicas es ligeramente diferente a la estructura cristalina.","title":"RMSD"},{"location":"simulacion_MD/#rmsf","text":"Despu\u00e9s, calculamos el RMSF ( Root mean square fluctuation ) para cada residuo. El RMSF es utilizado como una medida de la varianza conformacional de la estructura y nos indica las regiones de alta y baja movilidad. A continuaci\u00f3n, mostramos el RMSF para cada residuo. Destacamos que los residuos E201, W207, D248, D305, F325 y W329, que en bibliograf\u00eda se expuso que eran residuos conservados e implicados en la actividad enzim\u00e1tica, se localizan en m\u00ednimos locales de la gr\u00e1fica anterior, lo cual nos indican que tienen una baja movilidad.","title":"RMSF"},{"location":"simulacion_MD/#analisis-de-componente-principal","text":"El an\u00e1lisis de componente principal (PCA) puede utilizarse para estudiar las relaciones entre todas las conformaciones por las que pasa nuestra estructura en la simulaci\u00f3n. Este m\u00e9todo nos proporciona una serie de componentes principales (eigenvectores) que describen los ejes de m\u00e1xima varianza en la distribuci\u00f3n de las conformaciones. Esta t\u00e9cnica permite reducir la dimensionalidad de los datos (proyecto la distribuci\u00f3n original en el subespacio definido por los componentes principales que se consideren). De hecho, en simulaciones de este tipo realizadas de forma rigurosa se observa que con 3-5 dimensiones se puede capturar al menos el 70% de la varianza total de las fluctuaciones posicionales de los \u00e1tomos resultante de una simulaci\u00f3n de din\u00e1mica molecular (Grant et al., 2006) 2 . En nuestro caso, como se puede observar en la imagen de la esquina inferior derecha de la siguiente figura, son necesarias las 8 primeras componentes, aunque la mayor parte de la varianza queda recogida en las 3 primeras. En la siguiente imagen se muestran la distribuci\u00f3n de cada frame proyectadas en el subespacio definido por las 3 primeras componentes y coloreadas seg\u00fan el momento en el tiempo que les corresponde en la simulaci\u00f3n (de azul a rojo). Como se puede observar en la imagen anterior, se puede observar la evoluci\u00f3n progresiva de las conformaciones en la simulaci\u00f3n. En el eje de PC1 se puede observar como los valores en la proyecci\u00f3n tienden a aumentar con el tiempo y, como consecuencia, los frames iniciales y finales en la simulaci\u00f3n se separan notablemente. No sucede as\u00ed en el eje de PC2, donde los valores que toman los frames iniciales y finales son muy parecidos (podr\u00edamos interpretarlo de manera intuitiva como si la estructura \"volviese\" a la disposici\u00f3n inicial. Por \u00faltimo, en el eje PC3 observamos como los valores oscilan entre unos valores m\u00e1ximos y m\u00ednimos. Ser\u00eda muy interesante extender la simulaci\u00f3n de din\u00e1mica molecular en el tiempo para poder observar si dicho patr\u00f3n se mantiene. A continuaci\u00f3n, y para explorar m\u00e1s posibilidades en el an\u00e1lisis, realizamos un clustering en el espacio definido por las PC. Los resultados nos muestran dos grupos que corresponden a la evoluci\u00f3n temporal de la simulaci\u00f3n (es decir, conformaciones iniciales y finales), lo cual nos indica que el sistema estar\u00eda evolucionando de manera lineal y no peri\u00f3dica (alternando entre conformaciones, por ejemplo). El siguiente paso que damos, es preguntarnos por la contribuci\u00f3n de cada residuo a la varianza explicada por los dos primeros PC, lo cual se refleja en la siguiente figura (la l\u00ednea en negro corresponde a la PC1 y en azul a la PC2). Estos dos componentes, con una varianza acumulada del 50%, son explicados de manera bastante homog\u00e9nea por todos los residuos, aunque los picos en 240 y 295 nos pueden indicar que los residuos de dicha zona estar\u00edan alterando su conformaci\u00f3n de manera significativa.","title":"An\u00e1lisis de componente principal"},{"location":"simulacion_MD/#analisis-de-correlacion-cruzada","text":"Otro aspecto muy relevante en el an\u00e1lisis de las simulaciones de din\u00e1mica molecular es el estudio de c\u00f3mo las fluctuaciones o desplazamiento de un \u00e1tomo puede estar correlacionado con la fluctuaci\u00f3n de otro. De nuevo, para poder resultados fiables, ser\u00eda necesario disponer de una simulaci\u00f3n de ma\u015b duraci\u00f3n y realizada de manera m\u00e1s rigurosa aunque, con fines educativos, procederemos a estudiar las posibles correlaciones. Para ello, se construye una matriz compuesta por todos los coeficientes de correlaci\u00f3p cruzada por pares. Esta matriz se visualiza en la siguiente figura con una representaci\u00f3n gr\u00e1fica denominado DCCM ( dynamical cross-correlation map ). En concreto, nos interesan aquellas correlaciones entre residuos alejados en la secuencia de la prote\u00edna y que puedan deberse, por ejemplo, a interacciones en la estructura terciaria. Como puede observarse en la imagen anterior, se observan demasiadas se\u00f1ales entre todos los residuos, lo cual nos puede indicar que en la simulaci\u00f3n no se lleg\u00f3 a equilibrar el sistema y ser\u00eda necesario extender la simulaci\u00f3n en el tiempo. Estas correlaciones las podemos visualizar directamente sobre la estructura de la prote\u00edna utilizando el software pyMol. En la siguiente imagen se muestran algunas de las correlaciones en forma de l\u00edneas rojas y en forma de l\u00edneas azules las anticorrelaciones.","title":"An\u00e1lisis de correlaci\u00f3n cruzada"},{"location":"simulacion_MD/#referencias","text":"Arantes, P. R., Pol\u00eato, M. D., Pedebos, C., & Ligabue-Braun, R. (2021). Making it Rain: Cloud-Based Molecular Simulations for Everyone. Journal of Chemical Information and Modeling, 61(10), 4852-4856. https://doi.org/10.1021/acs.jcim.1c00998 \u21a9 Grant, B. J., Rodrigues, A. P. C., ElSawy, K. M., McCammon, J. A., & Caves, L. S. D. (2006). Bio3d: An R package for the comparative analysis of protein structures. Bioinformatics, 22(21), 2695-2696. https://doi.org/10.1093/bioinformatics/btl461 \u21a9 \u21a9 Hollingsworth, S. A., & Dror, R. O. (2018). Molecular Dynamics Simulation for All. Neuron, 99(6), 1129-1143. https://doi.org/10.1016/j.neuron.2018.08.011 \u21a9","title":"Referencias"},{"location":"testing/","text":"Test Unitarios \u00b6 A lo largo de esta asignatura, se han desarrollada un gran n\u00famero de funciones, muchas de las cuales han sido editadas y mejoradas en varias ocasiones. Por esta raz\u00f3n, y en los casos que nos parec\u00edan oportunos, decidimos hacer uso de fpcunit , un framework de test unitarios propio del entorno Lazarus para automatizar la realizaci\u00f3n de estos. Destacar que, para el desarrollo de aquellas funciones donde se nos ped\u00eda leer o escribir informaci\u00f3n en un formato concreto, hemos comenzado escribiendo primero el test antes que la propia funci\u00f3n. Esta idea, empleada en metodolog\u00edas de desarrollo como Test Driven Design, nos ha resultado de gran ayuda. Al hacerlo hemos cambiando el flujo de trabajo al que est\u00e1bamos acostumbrados, estableciendo primero las expectativas y especificaciones del c\u00f3digo en forma de test unitario, luego escribiendo el c\u00f3digo principal y mejor\u00e1ndolo hasta que superaba con \u00e9xito todos los test. Demostraci\u00f3n de uso \u00b6 A continuaci\u00f3n, mostramos algunos de los procedimientos que corresponden a test unitarios, as\u00ed como una animaci\u00f3n donde se muestra el funcionamiento de la interfaz gr\u00e1fica del mismo. Codigos AA Funciones Geometricas 1 2 3 4 5 6 7 8 9 10 11 procedure testing_biotools . CodigosAA ; begin IF AA3TO1 ( 'ALA' ) <> 'A' THEN Fail ( 'Fail AA3To1' ) ; IF AA1TO3 ( 'R' ) <> 'ARG' THEN Fail ( AA1TO3 ( 'R' )) ; IF AA1TO3 ( 'A' ) <> 'ALA' THEN Fail ( AA1TO3 ( 'A' )) ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 procedure testing_biotools . FuncionesGeometricas ; var V1 , V2 , V3 , V4 : TPunto ; begin V1 . X := 0 ; V1 . Y := 0 ; V1 . Z := 1 ; V2 . X := 2 ; V2 . Y := - 3 ; V2 . Z := 1 ; V3 . X := - 3 ; V3 . Y := 1 ; V3 . Z := 2 ; V4 . X := - 7 ; V4 . Y := - 7 ; V4 . Z := - 7 ; IF modulo ( V1 ) <> 1 THEN Fail ( 'Fail modulo()' ) ; IF distancia3D ( V1 , V1 ) <> 0 THEN Fail ( 'Fail distancia3d()' ) ; //IF angulo(V1, V3)*180/pi <> 180 THEN // Fail('Fail angulo()'); IF prodVectorial ( V2 , V3 ) <> V4 THEN Fail ( 'Fail prodVectorial()' ) ; end ; Figura 1. Animaci\u00f3n del programa testing mostrando su uso.","title":"Test Unitarios"},{"location":"testing/#test-unitarios","text":"A lo largo de esta asignatura, se han desarrollada un gran n\u00famero de funciones, muchas de las cuales han sido editadas y mejoradas en varias ocasiones. Por esta raz\u00f3n, y en los casos que nos parec\u00edan oportunos, decidimos hacer uso de fpcunit , un framework de test unitarios propio del entorno Lazarus para automatizar la realizaci\u00f3n de estos. Destacar que, para el desarrollo de aquellas funciones donde se nos ped\u00eda leer o escribir informaci\u00f3n en un formato concreto, hemos comenzado escribiendo primero el test antes que la propia funci\u00f3n. Esta idea, empleada en metodolog\u00edas de desarrollo como Test Driven Design, nos ha resultado de gran ayuda. Al hacerlo hemos cambiando el flujo de trabajo al que est\u00e1bamos acostumbrados, estableciendo primero las expectativas y especificaciones del c\u00f3digo en forma de test unitario, luego escribiendo el c\u00f3digo principal y mejor\u00e1ndolo hasta que superaba con \u00e9xito todos los test.","title":"Test Unitarios"},{"location":"testing/#demostracion-de-uso","text":"A continuaci\u00f3n, mostramos algunos de los procedimientos que corresponden a test unitarios, as\u00ed como una animaci\u00f3n donde se muestra el funcionamiento de la interfaz gr\u00e1fica del mismo. Codigos AA Funciones Geometricas 1 2 3 4 5 6 7 8 9 10 11 procedure testing_biotools . CodigosAA ; begin IF AA3TO1 ( 'ALA' ) <> 'A' THEN Fail ( 'Fail AA3To1' ) ; IF AA1TO3 ( 'R' ) <> 'ARG' THEN Fail ( AA1TO3 ( 'R' )) ; IF AA1TO3 ( 'A' ) <> 'ALA' THEN Fail ( AA1TO3 ( 'A' )) ; end ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 procedure testing_biotools . FuncionesGeometricas ; var V1 , V2 , V3 , V4 : TPunto ; begin V1 . X := 0 ; V1 . Y := 0 ; V1 . Z := 1 ; V2 . X := 2 ; V2 . Y := - 3 ; V2 . Z := 1 ; V3 . X := - 3 ; V3 . Y := 1 ; V3 . Z := 2 ; V4 . X := - 7 ; V4 . Y := - 7 ; V4 . Z := - 7 ; IF modulo ( V1 ) <> 1 THEN Fail ( 'Fail modulo()' ) ; IF distancia3D ( V1 , V1 ) <> 0 THEN Fail ( 'Fail distancia3d()' ) ; //IF angulo(V1, V3)*180/pi <> 180 THEN // Fail('Fail angulo()'); IF prodVectorial ( V2 , V3 ) <> V4 THEN Fail ( 'Fail prodVectorial()' ) ; end ; Figura 1. Animaci\u00f3n del programa testing mostrando su uso.","title":"Demostraci\u00f3n de uso"},{"location":"visualizacion/","text":"Visualizaci\u00f3n de las estructuras \u00b6 Este apartado se complementa con las im\u00e1genes y animaciones realizadas para ilustrar la revisi\u00f3n bibliogr\u00e1fica y el resto de actividades, cuando corresponde. En esas im\u00e1genes se buscaba utilizar las herramientas de un programa espec\u00edfico para visualizar la estructura de una prote\u00edna de forma general y en detalle (para visualizar el sitio activo, por ejemplo). En este apartado se realizan una serie de animaciones donde se busca comparar la estructura elegida, 2AFM, con una segunda estructura. Destacar que el archivo 2AFM.pdb utilizado es un archivo que ha sido \"limpiado\" manualmente para tener una \u00fanica copia de la prote\u00edna. Los archivos de estructura raw y procesados se pueden encontrar en en el directorio visualizaci\u00f3n/data . Adem\u00e1s, se muestran, a modo de ejemplo, algunos de los scripts utilizados, pero para asegurar la reproducibilidad el resto de scripts forma parte del c\u00f3digo del repositorio y pueden encontrarse en el directorio 'visualizaci\u00f3n' . Este apartado se corresponde a la 4\u00aa actividad de la relaci\u00f3n de ejercicios. Obtenci\u00f3n 2\u00aa estructura \u00b6 Adem\u00e1s de la estructura 2AFM se ha elegido una segunda estructura con el objetivo de poder compararlas en el software de visualizaci\u00f3n elegido. Esa segunda estructura corresponde a la estructura predicha por AlphaFold de Q16769, la cual corresponde a QPCT, es decir, a la isoforma secretora de hQC. Se ha escogido por dos razones, en primer lugar para comparar la estructura elegida, isoforma retenida, con la secretora y, en segunda lugar, para comparar una estructura cuyo origen es experimental con una obtenida mediante el uso de IA. AlphaFill \u00b6 Los modelos estructurales de la base de datos AlphaFold no tienen en cuenta entidades qu\u00edmicas distintas de los residuos de amino\u00e1cidos naturales y no poseen, por tanto, cofactores. Esto supone un inconveniente en nuestro caso porque, como vimos en el apartado de revisi\u00f3n bibliogr\u00e1fica, la prote\u00edna hQC posee un cofactor de \\(\\text{Zn}^{2+}\\) que es imprescindible para que tenga lugar la cat\u00e1lisis y es, por tanto, de gran inter\u00e9s. Esta limitaci\u00f3n sucede debido a que estos algoritmos de predicci\u00f3n (RoseTTAFold o AlphaFold, por ejemplo) no son capaces de resolver el problema del plegamiento de las prote\u00ednas mediante la comprensi\u00f3n de los principios f\u00edsicos subyacentes, sino que han descubierto intrincados patrones en base a las estructuras tridimensionales determinadas estructuralmente. Este inconveniente podemos intentar resolverlo haciendo uso del algoritmo AlphaFill, el cual ha sido recientemente publicado en forma de preprint. Este algoritmo enriquece los modelos de la base de datos AlphaFold \"transplantando\" mol\u00e9culas peque\u00f1as e iones comunes que se hayan observado en complejos con prote\u00ednas hom\u00f3logas muy similares en modelos determinados experimentalmente del banco de datos PDB-REDO7 (Hekkelman et al., 2021) 1 . El funcionamiento del algoritmo es, a grandes rasgos, como se muestra a continuaci\u00f3n: BLAST con la secuencia de AlphaFold con las secuencias alojadas en LAHMA webserver. Selecci\u00f3n hom\u00f3logos muy cercanos. Alineamiento de los esqueletos pept\u00eddicos. Integraci\u00f3n de los compuestos en los modelos de AlphaFold si no estaban previamente. Generaci\u00f3n nuevo modelo. Comparaci\u00f3n de 2AFM con Q16769 de AlphaFold \u00b6 A continuaci\u00f3n, se muestra una animaci\u00f3n en la que se pueden observar las estructuras 2AFM y Q16769 de AlphaFold tras ser alineadas. Se puede observar que, exceptuando la secuencia N-terminal responsable de su anclaje en el aparato de Golgi (diferencia biol\u00f3gica, puesto que son isoformas diferentes) y la ausencia de cofactores (limitaci\u00f3n causada por el mecanismo de obtenci\u00f3n de la estructura), ambas son extremadamente similares. Figura 1. Animaci\u00f3n de las estructuras 2AFM y Q16769. Elaboraci\u00f3n propia usando PyMol. Para realizar esta animaci\u00f3n se ha hecho uso de un peque\u00f1o script que combina comandos en PyMol con Python. set ray_opaque_background , off load data / processed / 2 AFM . pdb load data / raw / AF - Q16769 - F1 - model_v1 . pdb alignto 2 AFM , python import imageio step = 1 images = [] for a in range ( 0 , 180 , step ): cmd . rotate ( \"y\" , float ( step )) cmd . ray ( 500 , 500 ) filename = \"file\" + str ( a ) + \".png\" cmd . png ( filename ) images . append ( imageio . imread ( filename )) imageio . mimsave ( 'movie1.gif' , images ) python end Comparaci\u00f3n de 2AFM con Q16769 de AlphaFill \u00b6 A continuaci\u00f3n, se muestra la estructura experimental y la obtenida de AlphaFill alineadas. Se ha coloreado las sustancias inorg\u00e1nicas de la estructura experimental en marr\u00f3n y las de la estructura predicha en morado. Se puede observar que, para esta estructura, el algoritmo AlphaFill no funciona adecuadamente. En primer lugar porque, en el sitio catal\u00edtico (no se puede apreciar porque est\u00e1n superpuestos) aunque es capaz de determinar que es necesario alg\u00fan tipo de mol\u00e9cula cargada, se equivoca colocando un ion \\(\\text{Fe} ^{2+}\\) y no un ion \\(\\text{Zn}^{2+}\\) . En segundo lugar, porque no es capaz de predecir la presencia de un grupo sulfato y, en tercer lugar, porque predice la presencia de multitud de iones \\(\\text{Zn}^{2+}\\) fuera del sitio catal\u00edtico. El c\u00f3digo que se ha utilizado para conseguir dicha animaci\u00f3n es el siguiente: set ray_opaque_background , off load data / processed / 2 AFM . pdb load data / raw / Q16769_AlphaFill . cif alignto 2 AFM , remove solvent color brown , inorganic AND 2 AFM color purple , inorganic AND Q16769_AlphaFill select cofactors , byres inorganic expand 5 remove ( not cofactors ) hide cartoon , show sticks , center cofactors zoom python import imageio step = 1 images = [] for a in range ( 0 , 180 , step ): cmd . rotate ( \"y\" , float ( step )) # Rotate around Y-axis cmd . ray ( 500 , 500 ) filename = \"file\" + str ( a ) + \".png\" cmd . png ( filename ) images . append ( imageio . imread ( filename )) cmd . ray ( 500 , 500 ) filename = \"file\" + str ( a ) + \".png\" cmd . png ( filename ) images . append ( imageio . imread ( filename )) imageio . mimsave ( 'animation.gif' , images ) python end Figura 2. Animaci\u00f3n de las estructuras 2AFM y Q16769 mostrando cofactores y residuos colindantes. Elaboraci\u00f3n propia. Conclusi\u00f3n \u00b6 Por un lado, hemos podido observar c\u00f3mo la principal diferencia entre ambas isoformas es la secuencia N-terminal responsable de su anclaje en el aparato de Golgi (Figura 1) y como la isoforma gQC, a la que corresponde la estructura Q16769, est\u00e1 ligeramente m\u00e1s abierta en su sitio activo (Figura 2). Ambas ideas corroboran lo expuesto en el apartado de revisi\u00f3n bibliogr\u00e1fica. Por otro lado, hemos podido comprobar que AlphaFold2 es capaz de predecir estructuras de una alt\u00edsima calidad y que se superponen a la perfecci\u00f3n con estructuras experimentales. As\u00ed mismo, hemos podido observar una de las limitaciones de este algoritmo, ausencia de otras entidades qu\u00edmicas, y uno de los primeros intentos para superarla, AlphaFill. En este algoritmo, aunque no funciona de forma precisa, podemos ver la potencialidad de la premisa en que, aunque se equivoca en algunos aspectos, es capaz de acertar parcialmente en otros. Referencias \u00b6 Hekkelman, Maarten L., Ida de Vries, Robbie P. Joosten, y Anastassis Perrakis. \u00abAlphaFill: Enriching the AlphaFold Models with Ligands and Co-Factors\u00bb. Preprint. Bioinformatics, 27 de noviembre de 2021. https://doi.org/10.1101/2021.11.26.470110. \u21a9","title":"Visualizaci\u00f3n de las estructuras"},{"location":"visualizacion/#visualizacion-de-las-estructuras","text":"Este apartado se complementa con las im\u00e1genes y animaciones realizadas para ilustrar la revisi\u00f3n bibliogr\u00e1fica y el resto de actividades, cuando corresponde. En esas im\u00e1genes se buscaba utilizar las herramientas de un programa espec\u00edfico para visualizar la estructura de una prote\u00edna de forma general y en detalle (para visualizar el sitio activo, por ejemplo). En este apartado se realizan una serie de animaciones donde se busca comparar la estructura elegida, 2AFM, con una segunda estructura. Destacar que el archivo 2AFM.pdb utilizado es un archivo que ha sido \"limpiado\" manualmente para tener una \u00fanica copia de la prote\u00edna. Los archivos de estructura raw y procesados se pueden encontrar en en el directorio visualizaci\u00f3n/data . Adem\u00e1s, se muestran, a modo de ejemplo, algunos de los scripts utilizados, pero para asegurar la reproducibilidad el resto de scripts forma parte del c\u00f3digo del repositorio y pueden encontrarse en el directorio 'visualizaci\u00f3n' . Este apartado se corresponde a la 4\u00aa actividad de la relaci\u00f3n de ejercicios.","title":"Visualizaci\u00f3n de las estructuras"},{"location":"visualizacion/#obtencion-2a-estructura","text":"Adem\u00e1s de la estructura 2AFM se ha elegido una segunda estructura con el objetivo de poder compararlas en el software de visualizaci\u00f3n elegido. Esa segunda estructura corresponde a la estructura predicha por AlphaFold de Q16769, la cual corresponde a QPCT, es decir, a la isoforma secretora de hQC. Se ha escogido por dos razones, en primer lugar para comparar la estructura elegida, isoforma retenida, con la secretora y, en segunda lugar, para comparar una estructura cuyo origen es experimental con una obtenida mediante el uso de IA.","title":"Obtenci\u00f3n 2\u00aa estructura"},{"location":"visualizacion/#alphafill","text":"Los modelos estructurales de la base de datos AlphaFold no tienen en cuenta entidades qu\u00edmicas distintas de los residuos de amino\u00e1cidos naturales y no poseen, por tanto, cofactores. Esto supone un inconveniente en nuestro caso porque, como vimos en el apartado de revisi\u00f3n bibliogr\u00e1fica, la prote\u00edna hQC posee un cofactor de \\(\\text{Zn}^{2+}\\) que es imprescindible para que tenga lugar la cat\u00e1lisis y es, por tanto, de gran inter\u00e9s. Esta limitaci\u00f3n sucede debido a que estos algoritmos de predicci\u00f3n (RoseTTAFold o AlphaFold, por ejemplo) no son capaces de resolver el problema del plegamiento de las prote\u00ednas mediante la comprensi\u00f3n de los principios f\u00edsicos subyacentes, sino que han descubierto intrincados patrones en base a las estructuras tridimensionales determinadas estructuralmente. Este inconveniente podemos intentar resolverlo haciendo uso del algoritmo AlphaFill, el cual ha sido recientemente publicado en forma de preprint. Este algoritmo enriquece los modelos de la base de datos AlphaFold \"transplantando\" mol\u00e9culas peque\u00f1as e iones comunes que se hayan observado en complejos con prote\u00ednas hom\u00f3logas muy similares en modelos determinados experimentalmente del banco de datos PDB-REDO7 (Hekkelman et al., 2021) 1 . El funcionamiento del algoritmo es, a grandes rasgos, como se muestra a continuaci\u00f3n: BLAST con la secuencia de AlphaFold con las secuencias alojadas en LAHMA webserver. Selecci\u00f3n hom\u00f3logos muy cercanos. Alineamiento de los esqueletos pept\u00eddicos. Integraci\u00f3n de los compuestos en los modelos de AlphaFold si no estaban previamente. Generaci\u00f3n nuevo modelo.","title":"AlphaFill"},{"location":"visualizacion/#comparacion-de-2afm-con-q16769-de-alphafold","text":"A continuaci\u00f3n, se muestra una animaci\u00f3n en la que se pueden observar las estructuras 2AFM y Q16769 de AlphaFold tras ser alineadas. Se puede observar que, exceptuando la secuencia N-terminal responsable de su anclaje en el aparato de Golgi (diferencia biol\u00f3gica, puesto que son isoformas diferentes) y la ausencia de cofactores (limitaci\u00f3n causada por el mecanismo de obtenci\u00f3n de la estructura), ambas son extremadamente similares. Figura 1. Animaci\u00f3n de las estructuras 2AFM y Q16769. Elaboraci\u00f3n propia usando PyMol. Para realizar esta animaci\u00f3n se ha hecho uso de un peque\u00f1o script que combina comandos en PyMol con Python. set ray_opaque_background , off load data / processed / 2 AFM . pdb load data / raw / AF - Q16769 - F1 - model_v1 . pdb alignto 2 AFM , python import imageio step = 1 images = [] for a in range ( 0 , 180 , step ): cmd . rotate ( \"y\" , float ( step )) cmd . ray ( 500 , 500 ) filename = \"file\" + str ( a ) + \".png\" cmd . png ( filename ) images . append ( imageio . imread ( filename )) imageio . mimsave ( 'movie1.gif' , images ) python end","title":"Comparaci\u00f3n de 2AFM con Q16769 de AlphaFold"},{"location":"visualizacion/#comparacion-de-2afm-con-q16769-de-alphafill","text":"A continuaci\u00f3n, se muestra la estructura experimental y la obtenida de AlphaFill alineadas. Se ha coloreado las sustancias inorg\u00e1nicas de la estructura experimental en marr\u00f3n y las de la estructura predicha en morado. Se puede observar que, para esta estructura, el algoritmo AlphaFill no funciona adecuadamente. En primer lugar porque, en el sitio catal\u00edtico (no se puede apreciar porque est\u00e1n superpuestos) aunque es capaz de determinar que es necesario alg\u00fan tipo de mol\u00e9cula cargada, se equivoca colocando un ion \\(\\text{Fe} ^{2+}\\) y no un ion \\(\\text{Zn}^{2+}\\) . En segundo lugar, porque no es capaz de predecir la presencia de un grupo sulfato y, en tercer lugar, porque predice la presencia de multitud de iones \\(\\text{Zn}^{2+}\\) fuera del sitio catal\u00edtico. El c\u00f3digo que se ha utilizado para conseguir dicha animaci\u00f3n es el siguiente: set ray_opaque_background , off load data / processed / 2 AFM . pdb load data / raw / Q16769_AlphaFill . cif alignto 2 AFM , remove solvent color brown , inorganic AND 2 AFM color purple , inorganic AND Q16769_AlphaFill select cofactors , byres inorganic expand 5 remove ( not cofactors ) hide cartoon , show sticks , center cofactors zoom python import imageio step = 1 images = [] for a in range ( 0 , 180 , step ): cmd . rotate ( \"y\" , float ( step )) # Rotate around Y-axis cmd . ray ( 500 , 500 ) filename = \"file\" + str ( a ) + \".png\" cmd . png ( filename ) images . append ( imageio . imread ( filename )) cmd . ray ( 500 , 500 ) filename = \"file\" + str ( a ) + \".png\" cmd . png ( filename ) images . append ( imageio . imread ( filename )) imageio . mimsave ( 'animation.gif' , images ) python end Figura 2. Animaci\u00f3n de las estructuras 2AFM y Q16769 mostrando cofactores y residuos colindantes. Elaboraci\u00f3n propia.","title":"Comparaci\u00f3n de 2AFM con Q16769 de AlphaFill"},{"location":"visualizacion/#conclusion","text":"Por un lado, hemos podido observar c\u00f3mo la principal diferencia entre ambas isoformas es la secuencia N-terminal responsable de su anclaje en el aparato de Golgi (Figura 1) y como la isoforma gQC, a la que corresponde la estructura Q16769, est\u00e1 ligeramente m\u00e1s abierta en su sitio activo (Figura 2). Ambas ideas corroboran lo expuesto en el apartado de revisi\u00f3n bibliogr\u00e1fica. Por otro lado, hemos podido comprobar que AlphaFold2 es capaz de predecir estructuras de una alt\u00edsima calidad y que se superponen a la perfecci\u00f3n con estructuras experimentales. As\u00ed mismo, hemos podido observar una de las limitaciones de este algoritmo, ausencia de otras entidades qu\u00edmicas, y uno de los primeros intentos para superarla, AlphaFill. En este algoritmo, aunque no funciona de forma precisa, podemos ver la potencialidad de la premisa en que, aunque se equivoca en algunos aspectos, es capaz de acertar parcialmente en otros.","title":"Conclusi\u00f3n"},{"location":"visualizacion/#referencias","text":"Hekkelman, Maarten L., Ida de Vries, Robbie P. Joosten, y Anastassis Perrakis. \u00abAlphaFill: Enriching the AlphaFold Models with Ligands and Co-Factors\u00bb. Preprint. Bioinformatics, 27 de noviembre de 2021. https://doi.org/10.1101/2021.11.26.470110. \u21a9","title":"Referencias"},{"location":"write_PDB/","text":"WritePDB: Extraer \u00e1tomos Carbono alfa \u00b6 En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una funci\u00f3n que permite escribir la informaci\u00f3n relativa a un \u00e1tomo de un archivo PDB albergada en una estructura matricial en un fichero siguiendo el formato PDB de nuevo. El objetivo es emplear dicha funci\u00f3n para extraer los carbonos alfa de un fichero PDB, escribirlos en un archivo pseudo-pdb y estudiar el desorden de la prote\u00edna en base a su factor \\(\\text{B}\\) . El factor \\(\\text{B}\\) representa el desplazamiento de los \u00e1tomos de su posici\u00f3n media en la estructura cristalina y se observa como una disminuci\u00f3n en la intensidad de la difracci\u00f3n. Puede tener dos causas: ser el resultado de vibraciones at\u00f3micas dependientes de la temperatura o del desorden est\u00e1tico en la estructura cristalina. Podemos utilizarlo, por tanto, como indicador de los residuos m\u00e1s desordenados de la prote\u00edna (Trueblood et al., 1996) 1 . El c\u00f3digo correspondiente a esta funcionalidad se puede encontrar en la librer\u00eda biotools/src_biotools y la implementaci\u00f3n en un programa con interfaz gr\u00e1fica en el repositorio bajo el nombre de write_PDB . Este apartado se corresponde a la 5\u00aa actividad de la relaci\u00f3n de ejercicios. WriteAtomPDB \u00b6 En primer lugar, se desarroll\u00f3 una funci\u00f3n que escribiera el contenido de un record tipo TAtomPDB en una l\u00ednea tipo AnsiString correctamente formateada. Para hacerlo, se consult\u00f3 la bibliograf\u00eda proporcionada para familiarizarnos con el formato PDB. Para su desarrollo se definieron tambi\u00e9n una serie de test unitarios para asegurar la funci\u00f3n se comportaba de acuerdo a lo deseado. A continuaci\u00f3n, se muestra la funci\u00f3n WriteAtomPDB . Para escribirla se utiliz\u00f3 la funci\u00f3n formatfloat para convertir los valores num\u00e9ricos en cadenas de texto con los n\u00fameros decimales adecuados y la funci\u00f3n format para alinear dentro del n\u00famero de espacios que ocupa cada tipo de variable en los archivos PDB a la izquierda o a la derecha, seg\u00fan fuera necesario. Para ello se utiliza la sintaxis '%d' y es, en realidad, el aspecto de mayor dificultad de esta funci\u00f3n. Usando esta funci\u00f3n, que acepta como argumento instancias de clase AnsiString , evitamos tener que definir nosotros una funci\u00f3n que permita alinear los valores. A\u00f1adir que, puesto que no se consideraba el factor ocupancia en la estructura matricial TAtomPDB , no se ha incluido tampoco en este funci\u00f3n (por lo que todos los \u00e1tomos del pseudo-pdb tendr\u00e1n una ocupancia id\u00e9ntica e igual a 1.00). Funci\u00f3n WriteAtomPDB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function WriteAtomPDB ( atom : TAtomPDB ) : AnsiString ; var numatm , numres , X , Y , Z , R : AnsiString ; linea : AnsiString ; begin // Obtenemos la informaci\u00f3n del objeto atom en el formato num\u00e9rico que nos interesa numatm := inttostr ( atom . NumAtom ) ; numres := inttostr ( atom . NumRes ) ; X := formatfloat ( '0.000' , atom . coor . X ) ; Y := formatfloat ( '0.000' , atom . coor . Y ) ; Z := formatfloat ( '0.000' , atom . coor . Z ) ; R := formatfloat ( '0.00' , atom . R ) ; linea := Concat ( 'ATOM ' , // 6 char justificado a la izquierda format ( '%5s' , [ numatm ]) , // 5 char justificado a la derecha ' ' , //separador de espacios format ( '%-3s' , [ atom . ID ]) , ' ' + //No incluimos altLoc atom . residuo , ' ' , atom . subunidad , ' ' , format ( '%-4s' , [ numres ]) , //4 char justificado a la derecha ' ' , //No incluimos iCode ' ' , format ( '%7s' , [ X ]) , ' ' , format ( '%7s' , [ Y ]) , ' ' , format ( '%7s' , [ Z ]) , ' ' , format ( '%-5s' , [ '1.00' ]) , //No incluimosla ocupancia format ( '%-6s' , [ R ])) ; // No incluimos el resto de par\u00e1metros result := linea ; end ; TTestCase \u00b6 A continuaci\u00f3n, se muestra a modo de ejemplo uno de los test unitarios que se escribi\u00f3 para comprobar el buen funcionamiento de la funci\u00f3n writeAtomPDB() . testing_biotools.writePDB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 procedure testing_biotools . writePDB ; // 'ATOM 1 N ALA A 33 -6.424 -34.116 36.857 1.00 43.50') var atm : TAtomPDB ; str1 , str2 : AnsiSTring ; begin atm . NumAtom := 141 ; atm . ID := 'CA' ; atm . residuo := 'SER' ; atm . subunidad := 'A' ; atm . NumRes := 50 ; atm . coor . X := - 2 4.739 ; atm . coor . Y := - 2 4.229 ; atm . coor . Z := 0.489 ; atm . R := 2 2.73 ; str1 := WriteAtomPDB ( atm ) ; str2 := 'ATOM 141 CA SER A 50 -24.739 -24.229 0.489 1.00 22.73' ; IF NOT SameText ( trim ( str1 ) , str2 ) THEN begin Fail ( 'El formato no es el adecuado. ' ) ; end ; end ; Demostraci\u00f3n de uso \u00b6 A continuaci\u00f3n, se muestra una peque\u00f1a animaci\u00f3n donde se muestra la implementaci\u00f3n en una interfaz gr\u00e1fica del c\u00f3digo anterior. Destacar que, aunque el ejercicio ped\u00eda, en un principio, un programa capaz de extraer los carbonos \\(\\alpha\\) de un archivo PDB, nos pareci\u00f3 m\u00e1s adecuado generalizarlo a un programa capaz de extraer cualquier tipo de \u00e1tomo dado por el usuario. Figura 1. Animaci\u00f3n con ejemplo de uso de la aplicaci\u00f3n writePDB para extraer \u00e1tomos de cierto ID. Aplicaci\u00f3n con interfaz gr\u00e1fica realizada con Lazarus. Extracci\u00f3n carbonos alfa y visualizaci\u00f3n en PyMol seg\u00fan el factor B \u00b6 Por \u00faltimo, se realiz\u00f3 la tarea propuesta en el ejercicio. Se obtuvo un pseudo archivo PDB con los \u00e1tomos correspondientes a los carbonos \\(\\alpha\\) de la prote\u00edna 2AFM y, usando el programa PyMol, se obtuvo una animaci\u00f3n de la prote\u00edna en modo spacefill y coloreada seg\u00fan el factor B. En pos de la reproducibilidad, se muestra a continuaci\u00f3n tanto la animaci\u00f3n como el script utilizado para obtenerla. No se entrar\u00e1 en detalles al respecto de la obtenci\u00f3n de la animaci\u00f3n puesto que se ha seguido usando las mismas herramientas empleadas en el apartado de Visualizaci\u00f3n de este cuaderno de actividades. Visualizaci\u00f3n carbonos alfa 2AFM 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 set ray_opaque_background , off load write_PDB / data / 2 AFM_CA_pseudo . pdb spectrum b , blue_white_red , minimum = 10 , maximum = 50 as surface , label b > 60 , \"( %s , %s )\" % ( resn , resi ) python import imageio step = 1 images = [] for a in range ( 0 , 180 , step ): cmd . rotate ( \"y\" , float ( step )) cmd . ray ( 500 , 500 ) filename = \"file\" + str ( a ) + \".png\" cmd . png ( filename ) images . append ( imageio . imread ( filename )) imageio . mimsave ( 'pseudoPDB_b_factor.gif' , images ) python end Figura 2. Animaci\u00f3n de los carbonos \\(\\alpha\\) de la prote\u00edna 2AFM en modo spacefill y coloreados seg\u00fan el factor B. Adem\u00e1s, se han anotado los residuos que tuvieran un valor de B superior a 60 Interpretaci\u00f3n de los resultados \u00b6 En la animaci\u00f3n anterior podemos observar dos cadenas, A y B, que son distintas estructuralmente. Esto, aunque podr\u00eda ser poco intuitivo puesto que la prote\u00edna que estamos estudiando, 2AFM, es un mon\u00f3mero, sucede porque lo que contiene el PDB en realidad es la unidad asim\u00e9trica del cristal. Se puede observar c\u00f3mo una de las subunidades tiene mayor factor B que la otra. Es por ello que nos inclinamos a pensar que la \"versi\u00f3n m\u00e1s desordenada\" debe de ser fruto de errores experimentales (y que ha sido incluido en el PDB para mayor rigurosidad). Si nos fijamos en la estructura m\u00e1s ordenada, nos llama la atenci\u00f3n c\u00f3mo existen una serie de regiones en la superficie (coloreadas en rojo) de mayor Factor \\(\\text{B}\\) . Interpretamos estas zonas, algunas de ellas lazos, como regiones m\u00e1s flexibles de la prote\u00edna y que no poseen una estructura r\u00edgida. Esta idea es compatible con el hecho de que se encuentran situadas en la superficie de la prote\u00edna y podr\u00edamos hipotetizar que ser\u00edan regiones de interacci\u00f3n. Destacamos, por \u00faltimo, que los residuos de la subunidad \"ordenada\" del archivo PDB que se sab\u00eda por bibliograf\u00eda que eran importantes para la funci\u00f3n catal\u00edtica de la enzima (y que se podr\u00eda esperar, por ejemplo, una mayor flexibilidad) muestran valores de factor \\(\\text{B}\\) bajos, indicando as\u00ed que forman parte de zonas r\u00edgidas de la estructura. Conclusi\u00f3n \u00b6 En conclusi\u00f3n, el programa WritePDB es capaz de escribir pseudo archivos PDB con los que estudiar el desorden (fruto de errores experimentales pero tambi\u00e9n reflejo de la flexibilidad de la estructura) de una prote\u00edna. Esta informaci\u00f3n es de gran utilidad para valorar tanto las implicaciones biol\u00f3gicas que pueden tener regiones m\u00e1s r\u00edgidas o flexibles como evaluar la calidad de la estructura con que se est\u00e1 trabajando. Referencias \u00b6 Trueblood, K. N., H. B. B\u00fcrgi, H. Burzlaff, J. D. Dunitz, C. M. Gramaccioli, H. H. Schulz, U. Shmueli, y S. C. Abrahams. \u00abAtomic Dispacement Parameter Nomenclature. Report of a Subcommittee on Atomic Displacement Parameter Nomenclature\u00bb. Acta Crystallographica Section A Foundations of Crystallography 52, n.\u00ba 5 (1 de septiembre de 1996): 770-81. https://doi.org/10.1107/S0108767396005697. \u21a9","title":"WritePDB: Extraer \u00e1tomos Carbono alfa"},{"location":"write_PDB/#writepdb-extraer-atomos-carbono-alfa","text":"En la realizaci\u00f3n de este cuaderno de actividades se pide el desarrollo de una funci\u00f3n que permite escribir la informaci\u00f3n relativa a un \u00e1tomo de un archivo PDB albergada en una estructura matricial en un fichero siguiendo el formato PDB de nuevo. El objetivo es emplear dicha funci\u00f3n para extraer los carbonos alfa de un fichero PDB, escribirlos en un archivo pseudo-pdb y estudiar el desorden de la prote\u00edna en base a su factor \\(\\text{B}\\) . El factor \\(\\text{B}\\) representa el desplazamiento de los \u00e1tomos de su posici\u00f3n media en la estructura cristalina y se observa como una disminuci\u00f3n en la intensidad de la difracci\u00f3n. Puede tener dos causas: ser el resultado de vibraciones at\u00f3micas dependientes de la temperatura o del desorden est\u00e1tico en la estructura cristalina. Podemos utilizarlo, por tanto, como indicador de los residuos m\u00e1s desordenados de la prote\u00edna (Trueblood et al., 1996) 1 . El c\u00f3digo correspondiente a esta funcionalidad se puede encontrar en la librer\u00eda biotools/src_biotools y la implementaci\u00f3n en un programa con interfaz gr\u00e1fica en el repositorio bajo el nombre de write_PDB . Este apartado se corresponde a la 5\u00aa actividad de la relaci\u00f3n de ejercicios.","title":"WritePDB: Extraer \u00e1tomos Carbono alfa"},{"location":"write_PDB/#writeatompdb","text":"En primer lugar, se desarroll\u00f3 una funci\u00f3n que escribiera el contenido de un record tipo TAtomPDB en una l\u00ednea tipo AnsiString correctamente formateada. Para hacerlo, se consult\u00f3 la bibliograf\u00eda proporcionada para familiarizarnos con el formato PDB. Para su desarrollo se definieron tambi\u00e9n una serie de test unitarios para asegurar la funci\u00f3n se comportaba de acuerdo a lo deseado. A continuaci\u00f3n, se muestra la funci\u00f3n WriteAtomPDB . Para escribirla se utiliz\u00f3 la funci\u00f3n formatfloat para convertir los valores num\u00e9ricos en cadenas de texto con los n\u00fameros decimales adecuados y la funci\u00f3n format para alinear dentro del n\u00famero de espacios que ocupa cada tipo de variable en los archivos PDB a la izquierda o a la derecha, seg\u00fan fuera necesario. Para ello se utiliza la sintaxis '%d' y es, en realidad, el aspecto de mayor dificultad de esta funci\u00f3n. Usando esta funci\u00f3n, que acepta como argumento instancias de clase AnsiString , evitamos tener que definir nosotros una funci\u00f3n que permita alinear los valores. A\u00f1adir que, puesto que no se consideraba el factor ocupancia en la estructura matricial TAtomPDB , no se ha incluido tampoco en este funci\u00f3n (por lo que todos los \u00e1tomos del pseudo-pdb tendr\u00e1n una ocupancia id\u00e9ntica e igual a 1.00). Funci\u00f3n WriteAtomPDB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function WriteAtomPDB ( atom : TAtomPDB ) : AnsiString ; var numatm , numres , X , Y , Z , R : AnsiString ; linea : AnsiString ; begin // Obtenemos la informaci\u00f3n del objeto atom en el formato num\u00e9rico que nos interesa numatm := inttostr ( atom . NumAtom ) ; numres := inttostr ( atom . NumRes ) ; X := formatfloat ( '0.000' , atom . coor . X ) ; Y := formatfloat ( '0.000' , atom . coor . Y ) ; Z := formatfloat ( '0.000' , atom . coor . Z ) ; R := formatfloat ( '0.00' , atom . R ) ; linea := Concat ( 'ATOM ' , // 6 char justificado a la izquierda format ( '%5s' , [ numatm ]) , // 5 char justificado a la derecha ' ' , //separador de espacios format ( '%-3s' , [ atom . ID ]) , ' ' + //No incluimos altLoc atom . residuo , ' ' , atom . subunidad , ' ' , format ( '%-4s' , [ numres ]) , //4 char justificado a la derecha ' ' , //No incluimos iCode ' ' , format ( '%7s' , [ X ]) , ' ' , format ( '%7s' , [ Y ]) , ' ' , format ( '%7s' , [ Z ]) , ' ' , format ( '%-5s' , [ '1.00' ]) , //No incluimosla ocupancia format ( '%-6s' , [ R ])) ; // No incluimos el resto de par\u00e1metros result := linea ; end ;","title":"WriteAtomPDB"},{"location":"write_PDB/#ttestcase","text":"A continuaci\u00f3n, se muestra a modo de ejemplo uno de los test unitarios que se escribi\u00f3 para comprobar el buen funcionamiento de la funci\u00f3n writeAtomPDB() . testing_biotools.writePDB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 procedure testing_biotools . writePDB ; // 'ATOM 1 N ALA A 33 -6.424 -34.116 36.857 1.00 43.50') var atm : TAtomPDB ; str1 , str2 : AnsiSTring ; begin atm . NumAtom := 141 ; atm . ID := 'CA' ; atm . residuo := 'SER' ; atm . subunidad := 'A' ; atm . NumRes := 50 ; atm . coor . X := - 2 4.739 ; atm . coor . Y := - 2 4.229 ; atm . coor . Z := 0.489 ; atm . R := 2 2.73 ; str1 := WriteAtomPDB ( atm ) ; str2 := 'ATOM 141 CA SER A 50 -24.739 -24.229 0.489 1.00 22.73' ; IF NOT SameText ( trim ( str1 ) , str2 ) THEN begin Fail ( 'El formato no es el adecuado. ' ) ; end ; end ;","title":"TTestCase"},{"location":"write_PDB/#demostracion-de-uso","text":"A continuaci\u00f3n, se muestra una peque\u00f1a animaci\u00f3n donde se muestra la implementaci\u00f3n en una interfaz gr\u00e1fica del c\u00f3digo anterior. Destacar que, aunque el ejercicio ped\u00eda, en un principio, un programa capaz de extraer los carbonos \\(\\alpha\\) de un archivo PDB, nos pareci\u00f3 m\u00e1s adecuado generalizarlo a un programa capaz de extraer cualquier tipo de \u00e1tomo dado por el usuario. Figura 1. Animaci\u00f3n con ejemplo de uso de la aplicaci\u00f3n writePDB para extraer \u00e1tomos de cierto ID. Aplicaci\u00f3n con interfaz gr\u00e1fica realizada con Lazarus.","title":"Demostraci\u00f3n de uso"},{"location":"write_PDB/#extraccion-carbonos-alfa-y-visualizacion-en-pymol-segun-el-factor-b","text":"Por \u00faltimo, se realiz\u00f3 la tarea propuesta en el ejercicio. Se obtuvo un pseudo archivo PDB con los \u00e1tomos correspondientes a los carbonos \\(\\alpha\\) de la prote\u00edna 2AFM y, usando el programa PyMol, se obtuvo una animaci\u00f3n de la prote\u00edna en modo spacefill y coloreada seg\u00fan el factor B. En pos de la reproducibilidad, se muestra a continuaci\u00f3n tanto la animaci\u00f3n como el script utilizado para obtenerla. No se entrar\u00e1 en detalles al respecto de la obtenci\u00f3n de la animaci\u00f3n puesto que se ha seguido usando las mismas herramientas empleadas en el apartado de Visualizaci\u00f3n de este cuaderno de actividades. Visualizaci\u00f3n carbonos alfa 2AFM 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 set ray_opaque_background , off load write_PDB / data / 2 AFM_CA_pseudo . pdb spectrum b , blue_white_red , minimum = 10 , maximum = 50 as surface , label b > 60 , \"( %s , %s )\" % ( resn , resi ) python import imageio step = 1 images = [] for a in range ( 0 , 180 , step ): cmd . rotate ( \"y\" , float ( step )) cmd . ray ( 500 , 500 ) filename = \"file\" + str ( a ) + \".png\" cmd . png ( filename ) images . append ( imageio . imread ( filename )) imageio . mimsave ( 'pseudoPDB_b_factor.gif' , images ) python end Figura 2. Animaci\u00f3n de los carbonos \\(\\alpha\\) de la prote\u00edna 2AFM en modo spacefill y coloreados seg\u00fan el factor B. Adem\u00e1s, se han anotado los residuos que tuvieran un valor de B superior a 60","title":"Extracci\u00f3n carbonos alfa y visualizaci\u00f3n en PyMol seg\u00fan el factor B"},{"location":"write_PDB/#interpretacion-de-los-resultados","text":"En la animaci\u00f3n anterior podemos observar dos cadenas, A y B, que son distintas estructuralmente. Esto, aunque podr\u00eda ser poco intuitivo puesto que la prote\u00edna que estamos estudiando, 2AFM, es un mon\u00f3mero, sucede porque lo que contiene el PDB en realidad es la unidad asim\u00e9trica del cristal. Se puede observar c\u00f3mo una de las subunidades tiene mayor factor B que la otra. Es por ello que nos inclinamos a pensar que la \"versi\u00f3n m\u00e1s desordenada\" debe de ser fruto de errores experimentales (y que ha sido incluido en el PDB para mayor rigurosidad). Si nos fijamos en la estructura m\u00e1s ordenada, nos llama la atenci\u00f3n c\u00f3mo existen una serie de regiones en la superficie (coloreadas en rojo) de mayor Factor \\(\\text{B}\\) . Interpretamos estas zonas, algunas de ellas lazos, como regiones m\u00e1s flexibles de la prote\u00edna y que no poseen una estructura r\u00edgida. Esta idea es compatible con el hecho de que se encuentran situadas en la superficie de la prote\u00edna y podr\u00edamos hipotetizar que ser\u00edan regiones de interacci\u00f3n. Destacamos, por \u00faltimo, que los residuos de la subunidad \"ordenada\" del archivo PDB que se sab\u00eda por bibliograf\u00eda que eran importantes para la funci\u00f3n catal\u00edtica de la enzima (y que se podr\u00eda esperar, por ejemplo, una mayor flexibilidad) muestran valores de factor \\(\\text{B}\\) bajos, indicando as\u00ed que forman parte de zonas r\u00edgidas de la estructura.","title":"Interpretaci\u00f3n de los resultados"},{"location":"write_PDB/#conclusion","text":"En conclusi\u00f3n, el programa WritePDB es capaz de escribir pseudo archivos PDB con los que estudiar el desorden (fruto de errores experimentales pero tambi\u00e9n reflejo de la flexibilidad de la estructura) de una prote\u00edna. Esta informaci\u00f3n es de gran utilidad para valorar tanto las implicaciones biol\u00f3gicas que pueden tener regiones m\u00e1s r\u00edgidas o flexibles como evaluar la calidad de la estructura con que se est\u00e1 trabajando.","title":"Conclusi\u00f3n"},{"location":"write_PDB/#referencias","text":"Trueblood, K. N., H. B. B\u00fcrgi, H. Burzlaff, J. D. Dunitz, C. M. Gramaccioli, H. H. Schulz, U. Shmueli, y S. C. Abrahams. \u00abAtomic Dispacement Parameter Nomenclature. Report of a Subcommittee on Atomic Displacement Parameter Nomenclature\u00bb. Acta Crystallographica Section A Foundations of Crystallography 52, n.\u00ba 5 (1 de septiembre de 1996): 770-81. https://doi.org/10.1107/S0108767396005697. \u21a9","title":"Referencias"}]}